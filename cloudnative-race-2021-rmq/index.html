<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>【参赛总结】第二届云原生编程挑战赛-冷热读写场景的RocketMQ存储系统设计 - 徐靖峰|个人博客</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="Kirito的技术分享"><meta name="msapplication-TileImage" content="/img/avatar.png"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Kirito的技术分享"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="前言人总是这样，年少时，怨恨自己年少，年迈时，怨恨自己年迈，就连参加一场比赛，都会纠结，工作太忙怎么办，周末休息怎么办，成年人的任性往往就在那一瞬间，我只是单纯地想经历一场酣畅的性能挑战赛。所以，云原生挑战赛，我来了，Kirito 带着他的公众号来了。 读完寥寥数百多字的赛题描述，四分之一炷香之后一个灵感出现在脑海中，本以为这个灵感是开篇，没想到却是终章。临近结束，测试出了缓存命中率更高的方案，但"><meta property="og:type" content="blog"><meta property="og:title" content="【参赛总结】第二届云原生编程挑战赛-冷热读写场景的RocketMQ存储系统设计"><meta property="og:url" content="https://www.cnkirito.moe/cloudnative-race-2021-rmq/"><meta property="og:site_name" content="徐靖峰|个人博客"><meta property="og:description" content="前言人总是这样，年少时，怨恨自己年少，年迈时，怨恨自己年迈，就连参加一场比赛，都会纠结，工作太忙怎么办，周末休息怎么办，成年人的任性往往就在那一瞬间，我只是单纯地想经历一场酣畅的性能挑战赛。所以，云原生挑战赛，我来了，Kirito 带着他的公众号来了。 读完寥寥数百多字的赛题描述，四分之一炷香之后一个灵感出现在脑海中，本以为这个灵感是开篇，没想到却是终章。临近结束，测试出了缓存命中率更高的方案，但"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://image.cnkirito.cn/%E6%8E%92%E5%90%8D.png"><meta property="og:image" content="https://image.cnkirito.cn/image-20211031213450519.png"><meta property="og:image" content="https://image.cnkirito.cn/image-20211101000719405.png"><meta property="og:image" content="https://image.cnkirito.cn/image-20211101000127272.png"><meta property="article:published_time" content="2021-11-02T19:00:24.000Z"><meta property="article:modified_time" content="2025-07-01T03:18:09.727Z"><meta property="article:author" content="徐靖峰"><meta property="article:tag" content="文件IO"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="https://image.cnkirito.cn/%E6%8E%92%E5%90%8D.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://www.cnkirito.moe/cloudnative-race-2021-rmq/"},"headline":"【参赛总结】第二届云原生编程挑战赛-冷热读写场景的RocketMQ存储系统设计","image":["https://image.cnkirito.cn/%E6%8E%92%E5%90%8D.png","https://image.cnkirito.cn/image-20211031213450519.png","https://image.cnkirito.cn/image-20211101000719405.png","https://image.cnkirito.cn/image-20211101000127272.png"],"datePublished":"2021-11-02T19:00:24.000Z","dateModified":"2025-07-01T03:18:09.727Z","author":{"@type":"Person","name":"徐靖峰"},"description":"前言人总是这样，年少时，怨恨自己年少，年迈时，怨恨自己年迈，就连参加一场比赛，都会纠结，工作太忙怎么办，周末休息怎么办，成年人的任性往往就在那一瞬间，我只是单纯地想经历一场酣畅的性能挑战赛。所以，云原生挑战赛，我来了，Kirito 带着他的公众号来了。 读完寥寥数百多字的赛题描述，四分之一炷香之后一个灵感出现在脑海中，本以为这个灵感是开篇，没想到却是终章。临近结束，测试出了缓存命中率更高的方案，但"}</script><link rel="canonical" href="https://www.cnkirito.moe/cloudnative-race-2021-rmq/"><link rel="icon" href="/img/avatar.png"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.12.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><script src="https://www.googletagmanager.com/gtag/js?id=UA-118574570-1" async></script><script>window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
    
        gtag('config', 'UA-118574570-1');</script><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.css"><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><!--!--><!--!--><meta name="generator" content="Hexo 5.4.0"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/avatar.png" alt="徐靖峰|个人博客" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/.">主页</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/archives">归档</a><a class="navbar-item" href="/about">关于</a><a class="navbar-item" target="_blank" rel="noopener" href="https://github.com/YunaiV/onemall">开源项目</a></div><div class="navbar-end"><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-9-widescreen"><div class="card"><article class="card-content article" id="article-content" role="article"><h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal"><i class="fas fa-angle-double-right"></i>【参赛总结】第二届云原生编程挑战赛-冷热读写场景的RocketMQ存储系统设计</h1><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><i class="far fa-calendar-alt"> </i><time dateTime="${date_xml(page.date)}" title="${date_xml(page.date)}">2021-11-02</time></span><span class="level-item is-hidden-mobile"><i class="far fa-calendar-check"> </i><time dateTime="${date_xml(page.updated)}" title="${date_xml(page.updated)}">2025-07-01</time></span><span class="level-item"><a class="link-muted" href="/categories/%E6%80%A7%E8%83%BD%E6%8C%91%E6%88%98%E8%B5%9B/">性能挑战赛</a></span><span class="level-item">41 分钟读完 (大约6160个字)</span></div></div><div class="content"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>人总是这样，年少时，怨恨自己年少，年迈时，怨恨自己年迈，就连参加一场比赛，都会纠结，工作太忙怎么办，周末休息怎么办，成年人的任性往往就在那一瞬间，我只是单纯地想经历一场酣畅的性能挑战赛。所以，云原生挑战赛，我来了，Kirito 带着他的公众号来了。</p>
<p>读完寥寥数百多字的赛题描述，四分之一炷香之后一个灵感出现在脑海中，本以为这个灵感是开篇，没想到却是终章。临近结束，测试出了缓存命中率更高的方案，但评测已经没有了日志，在茫茫的方案之中，我错过了最大的那一颗麦穗，但在一个月不长不短的竞赛中，我挑选到了一颗不错的麦穗，从此只有眼前路，没有身后身，最终侥幸跑出了内部赛第一的成绩。</p>
<p><img src="https://image.cnkirito.cn/%E6%8E%92%E5%90%8D.png"></p>
<p>传统存储引擎类型的比赛，主要是围绕着两种存储介质：SSD 和 DRAM，不知道这俩有没有熬过七年之痒，Intel 就已经引入了第三类存储介质：AEP（PMem 的一种实现）。AEP 的出现，让原本各司其职的 SSD 和 DRAM 关系变得若即若离起来，它既可以当做 DRAM 用，也可以当做 SSD 用。蕴含在赛题中的”冷热存储“这一关键词，为后续风起云涌的赛程埋下了伏笔，同时给了 AEP 一个名分。</p>
<p>AEP 这种存储介质不是第一次出现在我眼前，在 ADB 比赛中就遇到过它，此次比赛开始时，脑子里面对它仅存的印象便是”快”。这个快是以 SSD 为参照物，无论是读还是写，都高出传统 SSD 1~n 个数量级。但更多的认知，只能用 SSD 来类比，AEP 特性的理解和使用方法，无疑是这次的决胜点之一。</p>
<p>曾经的我喜欢问，现在的我喜欢试。一副键盘，一个深夜，我窥探到了 AEP 的奥秘，多线程读写必不可少，读取速度和写入速度近似 DRAM，但细究之下写比读慢，从整体吞吐来看，DRAM 的读写性能略优于 AEP，但 DRAM 和 AEP 的读写都比 SSD 快得多的多。我的麦穗也有了初步的模样：第一优先级是降低 SSD 命中率，在此基础上，提高 DRAM 命中率，AEP 起到平衡的效果，初期不用特别顾忌 AEP 和 DRAM 的命中比例。</p>
<span id="more"></span>

<h2 id="参赛历程"><a href="#参赛历程" class="headerlink" title="参赛历程"></a>参赛历程</h2><p>万事开头难，中间难，后段也难。</p>
<p>和参加比赛的大多数人一样，我成功卡在了第一步：出分。AEP 先别用了，缓存方案也暂且搁置，不愧是 RocketMQ 团队出的题目，队列众多，那就先用 RocketMQ 的经典方案，“一阶段多线程绑定分区文件，顺序追加写，索引好办，内存和文件各存一份；二阶段随机读”，说干就干，两个小时后，果然得到了“正确性检测失败”的提示。把时间轴拉到去年，相比之下今年的参赛队伍并没有降低很多，但出分的队伍明显下降，大多数人是卡在了正确性检测这一关。咨询出题人，得知这一次的正确性检测是实实在在的”掉电“，PageCache 是指望不上了，只能派 <code>FileChannel#force()</code> 出场，成功获得了第一份成绩：1200s，一份几乎快超时的成绩。</p>
<blockquote>
<p>使用 force 解决掉电数据不丢失可以参考我赛程初段写的文章：<a href="https://www.cnkirito.moe/filechannel_force/">https://www.cnkirito.moe/filechannel_force/</a></p>
</blockquote>
<p>优化成功的喜悦片刻消散，初次出分的悸动至死不渝。那种感觉就像一觉醒来，发现今天是周六，可以睡到中午，甚至后面还有一个周日一样放肆。有了 baseline，下面便可以开始着手优化了，刚起头儿，有的是功夫，有的是希望。</p>
<p>掉电的限制，使得 SSD 的写入方案十分受限，每一条数据都要 force，使得 pageCache 近似无效，pageCache 从来没有受过这样的委屈，我走还不行吗？</p>
<p>随着赛程持续推进，也就推进了一天吧，我开始着手优化合并写入方案。传统方案中，聚合写入往往使用 DRAM 作为写入缓冲，聚合同一线程内前后几条消息，以减少写入放大问题，也有诸如 MongoDB 之流，会选择合并同一批次多个线程之间的数据，按照题意，多个线程合并写入，一起 force 已然是题目的唯一解。团结就是力量，经过测试，n 个线程聚合在一起 force，一起返回，可以显著降低 force 的总次数，缓解写入放大问题，有效地提升了分数。n 多少合适呢？理论分析，n 过大，实际 IO 线程就会变少；n 过小，force 次数多，解决调参问题，最合适的是机器学习，其次是 benchmark，经过多轮 benchmark，4 组 x 10 线程最为合适，4 个 IO 线程正好 = CPU core，这非常的合理。</p>
<p>合并写入后，效果显著，成绩来到了 700~800s。如果没有 AEP，这个比赛也就到头了，AEP 的加入，像草一样，一切都卷了起来。</p>
<p>赛程中段，有朋友在微信交流群中问我，AEP 你有用起来吗？每个人都会经历这个阶段：看见一座山，就想知道山后面是什么。我很想告诉他，可能翻过去山后面，你会发觉没有什么特别。回头看，会觉得这一边更好。但我知道他不会听，以他的性格，自己不试过，又怎么会甘心？我的 trick 无足轻重，他最终还是使用了 AEP，感受到了蒸汽火车到高铁那般速度的提升。总数据 125G，AEP 容量 60G，即使固定存储最后的 60G 数据，也可以确保热读部分的数据全部命中 AEP，SSD 会因为你的刻意保持距离而感到失落，你的分数不会。</p>
<p>即便是这样不经任何设计的 AEP 缓存方案，得益于 AEP 的读写速度和较大的容量加持，也可以获得 600s+ 的分数。 </p>
<p>分数这个东西，总是比昨天高一点，比明天少一点，但要想维持这样的分数增长，需要持续付出极大的努力。600s 显然不足以支撑进入决赛，AEP 缓存固定的数据也显得有点呆，就像你意外获得了一块金刚石，不经雕琢，则无法成为耀眼夺目的钻石。必须优化 AEP 的使用方案！因为有热数据的存在，写入的一部分数据会在较短的一段时间内被消费，缓存方案也需要联动起来，写入-&gt; 消费 -&gt; 写入 -&gt; 消费，大脑中飞速地模拟、推测评测程序的流程，操作系统、计算机网络的概念被一遍遍检索，最终锁定在了一个耳熟能详的概念：TCP 滑动窗口。AEP 保存最热的 60G 数据，使得热读全部命中，根据测试，发现冷读也会很快变成热读，在思路和方案连接的那一刻，代码流程也直接显现了出来，三又二分之一小时后，我提交了这份 AEP 滑动窗口的方案，没有什么比一次 Acccept 更爽的事了，一边赞叹自己的编码能力，一边自负地停止了优化，成绩停留在了 504s。</p>
<p>十月八号零点八分，钟楼敲响后的八分钟，我手握着一杯水，打开了排行榜，看到不少 500+ 的分数，懊恼、恐慌、焦虑一下子涌上了心头，水也越饮越寒。我本有七天时间，优化我的方案，但我没有；我在等一个奇迹，期待大家忘掉这场比赛，放弃优化，让排行榜锁定在十月一号那一天，但它没有。我将这份烦恼倾诉给妻子，换来了她的安慰，在她心目中，我永远是最棒的。我内心忐忑地依附道，那当然…在之后的晚上，世上少了一个 WOT 的玩家，多了一个埋头在 IDEA 中追求极致性能的码农。</p>
<p>在很长的一段时间里，我一直在追求降低 SSD 的命中率，每降低一点，我的分数总能够提升几秒。不知道从哪一天起，我看到排行榜中出现了一些 450s 的成绩，起初这并没有引起的我的警觉，因为 hack 可以很容易达到 300s，我一开始预估的极限成绩，不过也就是 470s，对，这一定是 hack，心里一遍遍地默念着。但，万一不是呢？</p>
<p>太想伸手摘取星星的人，常常忘记脚下的鲜花。我开始翻阅赛题描述，以寻找是否有遗漏的信息；一遍遍 review 自己的代码，调整代码结构，优化代码细节；检索自己过往的博文，以寻找可能擦肩而过的优化点。往后的几个晚上，我做的是同一个梦，梦里面重复播放着自己曾经的优化经验：4kb 对齐、文件预分配、缓存行填充…忽然间想起，自己总结的优化经验还没有完全尝试过。这次比赛是从第一次写入开始计时的，选手们可以在构造函数中恣意地预先分配一些数据，例如对象提前 new 好，内存提前 allocate，减少 runtime 时期的耗时，而这其中最有用的优化，当属 SSD 文件的预分配和 4kb 填充了。在 append 之前，事先把文件用 0 填充，得到总长度略大于 125G 的空白文件，在写入时，不足 4kb 的部分使用 4kb 填充，即使多写了一部分数据，速度还是能够提升，换算成实际的写入速度，可以达到 310M/s，而在此之前，force 的存在使得写入瓶颈始终卡在 275M/s。宁可一思进，莫在一思留，方案调通后，成绩锁定在了 440s。</p>
<p>内部赛结束前的两周，我又萌生了一个大胆的想法，考虑到 getRange 命中 SSD 时，系统采用的是抽样检测，那是不是意味着，用 mmap 读取就变成了一种懒加载呢？这个思路虽然在实际生产中不太通用，但在赛场上，那可以一把利器，这把利器斩下了 412s 的分数，也割伤了自己，评委不让用！我的天，我浪费了宝贵的两周，浪费在了一个无法通过的方案上。天知道评测是在抽样检测，我只是认为 mmap 读会更快呀 ：）</p>
<p>不知道从什么时候开始，在什么东西上面都有个日期，秋刀鱼会过期，肉罐头会过期，比赛也在 10.26 号这天迎来了结束。未竟的优化,设想的思路，没能完成方案改造的遗憾都在这一刻失去了意义。我已经很久没有打过比赛了，也很久没有这样为一个方案绞尽脑汁了，这场比赛就这样任性地画上了一个句号。</p>
<h2 id="最终方案"><a href="#最终方案" class="headerlink" title="最终方案"></a>最终方案</h2><h3 id="SSD-写入方案"><a href="#SSD-写入方案" class="headerlink" title="SSD 写入方案"></a>SSD 写入方案</h3><p><img src="https://image.cnkirito.cn/image-20211031213450519.png" alt="写入方案"></p>
<p>缓存架构是制胜点，SSD 的写入方案则是基本面，相信绝大多数前排的选手，都采用了上述的架构。性能评测阶段固定有 40 个线程，我将线程分为了 4 组，每组 10 个线程，进行 IO 合并。为什么是 4组在参赛历程中也介绍过，尊重 benchmark 的结果。1~9 号线程写入缓冲区完毕之后就 await 进入阻塞态，留下 10 号线程进行 IO，刷盘之后，notify 其他线程返回结果，如此往复，是一个非常经典的生产者消费者模式。</p>
<p>由于这次比赛，recover 阶段是不计入得分的，为了降低 force 的开销，我选择将索引的持久化和数据存在一起，这样避免了单独维护索引文件。在我的方案中，索引需要维护 topic，queue，length 三个信息，只需要定长的 5 个字节，和 100b~17Kb 的数据相比，微不足道，合并之后收益是很明显的。</p>
<p>选择使用 JUC 提供的 Lock + Condition 实现 wait/notify，一则是自己比较习惯这么控制并发，二则是复用其中一个 append 线程做刷盘的 IO 线程，相比其他并发方案的线程切换，要少一点。事实上，这次比赛中，CPU 是非常富余的，不会成为瓶颈，该模式的优势并没有完全发挥出来。</p>
<p>4kb 对齐是 SSD 经典的优化技巧，尽管并不是每一次性能挑战赛它都能排上用场，但请务必不要忘记尝试它。它对于人们的启发是使用 4kb 整数倍的写入缓冲聚合数据，整体刷盘，从而避免读写放大问题。此次比赛稍显特殊，由于赛题数据的随机分布特性，10 个线程聚合后的数据，往往不是 4KB 的整数倍，但这不妨碍我们做填充，看似多写入了一部分无意义的数据，但实际上会使得写入速度得到提升，尤其是在 force 情况下。</p>
<p>我曾和 @chender 交流过 4KB 填充这个话题，尝试分析出背后的原因，这里的结论不一定百分之百正确。4KB 是 SSD 的最小读写单元，这涉及硬件的操作，如果不填充，考虑以下执行流程，写入 9KB，force，写入 9 Kb，force，如果不做填充，相当于 force 了 9+3+3+9+3=27 kb，中间交叉的 3 kb，在 force 时会被重复计算，而填充过后，一定是 force 了 9+3+9+3=24 kb，整体 force 量降低。还有一个可能的依据是，没有填充的情况下，其实一定程度破坏了顺序写，写入实际写入了 12kb，但第二次写入并没有从 12kb 开始写入，而是从 9kb 写入。总之在 benchmark 下，4kb 对齐确实带来了 15s+ 的收益。</p>
<p>写入阶段还有一个致胜的优化，文件预分配。在 C 里面，有 fallocate，而 Java 并没有对应的 JNI 调用，不过可以取巧，利用 append 开始计分这个评测特性，在 SSD 上先使用字节 0 填充整个文件。在预分配过后，使用 force 也可以获得跟不使用 force 一样的写入速度，几乎打满了 320M/s 的 IO 速度。这个优化点，我在之前的博客中也分享过，不知道有没有其他选手看到并利用了起来，如果漏掉了这个优化，真的有点可惜，因为它足足可以让方案快 50s 左右。 </p>
<h3 id="缓存架构"><a href="#缓存架构" class="headerlink" title="缓存架构"></a>缓存架构</h3><p><img src="https://image.cnkirito.cn/image-20211101000719405.png" alt="全局架构"></p>
<p>上图是全局缓存架构，整体方案的思路是多级缓存，采用滑动窗口的思想，AEP 永远缓存最新的 60G 数据，以确保热数据一定不会命中 SSD。同时，堆外的 2G DRAM 与 AEP 息息相关，这部分 DRAM 有两个作用，其一是作为 AEP 的写入缓冲，规避 AEP 写入放大的问题，其二是作为热数据的 DRAM 缓存，最热的一部分数据，可以保证直接命中 DRAM，规避 AEP 的访问。另外富余的 3G 的堆内内存，可以用于缓存由于滑动而导致被覆盖的数据，这部分 DRAM 同时配备引用计数，从而达到复用的效果。</p>
<p><img src="https://image.cnkirito.cn/image-20211101000127272.png" alt="缓存读写流程"></p>
<p>在具体实现中，我将 60G 平均分配给 40 个线程，每个线程持有 1.5G 的 AEP 可用缓存，50M 的 DRAM 缓存。可以发现，在我的方案中，SSD 写入方案和 AEP 是不同的，SSD 由于 force 的限制，采用了线程合并写入，而 AEP 本身就是可以丢失的缓存，所以不需要进行合并，每个线程维护自身的 AEP 和 DRAM 缓存即可。</p>
<p>每个线程除了配备 1.5G 的AEP，还分配了 50M 的 DRAM。这部分 DRAM 永远被优先写入，同样的，也会优先被读取，前提是命中了的话。50M 显然不是一个特别大的空间，所以在其充满时，将 50M 数据整体刷入 AEP 中，使用 ByteBuffer 作为 DRAM 的 manager，还可以利用其逻辑 clear 的操作，使得 DRAM 和 AEP 一样变成了一个 RingBuffer。这部分设计算是我方案中比较巧妙的一点。</p>
<p>当然，你永远可以相信 SSD，它是最后一道兜底逻辑，无论缓存设计的多么糟糕，保证最后能够命中 SSD 才能出分，所有人都清楚这一点。</p>
<p>AEP 滑动窗口的实现其实并不复杂，详见文末的代码，我就不过多介绍了。</p>
<h2 id="程序优化"><a href="#程序优化" class="headerlink" title="程序优化"></a>程序优化</h2><h3 id="预分配文件"><a href="#预分配文件" class="headerlink" title="预分配文件"></a>预分配文件</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">preAllocateFile</span><span class="params">(FileChannel fileChannel, <span class="keyword">long</span> threadGroupPerhapsFileSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> bufferSize = <span class="number">4</span> * <span class="number">1024</span>;</span><br><span class="line">    ByteBuffer byteBuffer = ByteBuffer.allocateDirect(bufferSize);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bufferSize; i++) &#123;</span><br><span class="line">        byteBuffer.put((<span class="keyword">byte</span>)<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    byteBuffer.flip();</span><br><span class="line">    <span class="keyword">long</span> loopTimes = threadGroupPerhapsFileSize / bufferSize;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">long</span> i = <span class="number">0</span>; i &lt; loopTimes; i++) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            fileChannel.write(byteBuffer);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        byteBuffer.flip();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        fileChannel.force(<span class="keyword">true</span>);</span><br><span class="line">        fileChannel.position(<span class="number">0</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>简单实用的一个优化技巧，属于发现就可以很快实现的一个优化，但可能不容易发现。</p>
<h3 id="4KB-对齐"><a href="#4KB-对齐" class="headerlink" title="4KB 对齐"></a>4KB 对齐</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">force</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 4kb 对齐</span></span><br><span class="line">    <span class="keyword">int</span> position = writeBuffer.position();</span><br><span class="line">    <span class="keyword">int</span> mod = position % Constants._4kb;</span><br><span class="line">    <span class="keyword">if</span> (mod != <span class="number">0</span>) &#123;</span><br><span class="line">    		writeBuffer.position(position + Constants._4kb - mod);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    writeBuffer.flip();</span><br><span class="line">    fileChannel.write(writeBuffer);</span><br><span class="line">    fileChannel.force(<span class="keyword">false</span>);</span><br><span class="line">    writeBuffer.clear();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同上</p>
<h3 id="Unsafe"><a href="#Unsafe" class="headerlink" title="Unsafe"></a>Unsafe</h3><p>其实感觉用了 Unsafe 也没有多少提升，因为后期抖动太大了，但最优成绩的确是用 Unsafe 跑出来的，还是罗列出来，万一下次有用呢？详见代码实现 <code>io.openmessaging.NativeMemoryByteBuffer</code>。</p>
<p>推荐阅读：《<a href="https://www.cnkirito.moe/unsafe/">聊聊Unsafe的一些使用技巧</a>》</p>
<h3 id="ArrayMap"><a href="#ArrayMap" class="headerlink" title="ArrayMap"></a>ArrayMap</h3><p>可以使用数组重写一遍 Map，反正此次比赛调用到的 Map 的 API 也不多，换成数组实现之后，可以降低 HashMap 的 overheap，再优秀的实现，在数组面前也会变得黯淡无光，仅限于比赛。</p>
<p>详见代码实现 <code>io.openmessaging.ArrayMap</code>。</p>
<h3 id="预初始化"><a href="#预初始化" class="headerlink" title="预初始化"></a>预初始化</h3><p>充分利用 append 之前的耗时不计入总分这一特性。除了将文件提前分配出来之外，Runtime 需要 new 的对象、DRAM 空间等，都提前在构造函数中完成，蚊子腿也是肉，分数总是这么一点点抠出来的。</p>
<h3 id="并发-getRange"><a href="#并发-getRange" class="headerlink" title="并发 getRange"></a>并发 getRange</h3><p>读取阶段 fetchNum 最大为 100，串行访问的话，如果是命中缓存还好，要是 100 次 SSD 的 IO 都是串行，那可就太糟糕了。经过测试，仅当命中 SSD 时并发访问，和不区分内存、AEP、SSD 命中，均并发访问，效果差不多，但无论如何，并发 getRange 总是比串行好的。</p>
<h3 id="ThreadLocal-复用"><a href="#ThreadLocal-复用" class="headerlink" title="ThreadLocal 复用"></a>ThreadLocal 复用</h3><p>性能挑战赛中务必要 check 的一个环节，便是在运行时有没有动态 new 对象，有没有动态 allocate 内存，出现这些可是大忌，建议全部用 ThreadLocal 缓存。这次的赛题中有很多关键性的数字，100 个 Topic、40 个线程，稍加不留意，可能把线程级别的一些操作，错当成 Topic 级别来设计，例如分配的写入缓冲也好，getRange 阶段复用的读取缓冲也好，都应该设计成线程级别的数据。ThreadLocal 第一是方便管理线程级别的资源，第二是因为线程相对于 Topic 是要少的，需要搞清楚，哪些资源是线程级别的，哪些是 Topic 级别的，避免资源浪费。</p>
<h3 id="合并写入"><a href="#合并写入" class="headerlink" title="合并写入"></a>合并写入</h3><p>详见源码<code>io.openmessaging.ThreadGroupManager#append</code></p>
<h3 id="AEP-滑动窗口"><a href="#AEP-滑动窗口" class="headerlink" title="AEP 滑动窗口"></a>AEP 滑动窗口</h3><p>详见源码<code>io.openmessaging.AepManager</code></p>
<h2 id="总结与反思"><a href="#总结与反思" class="headerlink" title="总结与反思"></a>总结与反思</h2><p>一言以蔽之，滑动窗口缓存是我整个方案的核心，虽然这个方案经过细节的优化，让我取得了内部赛第一的成绩，但开篇我也提到过，它并不是缓存命中率最高的方案，在这个方案中，第一个明显的问题便是，堆外 DRAM 和 AEP 可能缓存了同一批数据，实际上，DRAM 和 AEP 缓存不重叠的方案肯定会有更高的缓存命中率；第二个问题，也是问题一连带的问题，在该方案中，堆内的 DRAM 无法被很高效地利用起来，所以我在本文中，只是稍带提了一下堆内的设计，没有详细介绍引用技术的逻辑。</p>
<p>我在赛程后半段，也尝试设计过 DRAM 和 AEP 不重叠并且动态分配回收的方案，缓存利用率的确会更高，但这意味着我要放弃滑动窗口方案中所有的细节调优！业余时间搞比赛，实在是精力时间有限，最终选择了放弃。</p>
<p>这像极了项目开发的技术债，如果你选择忍受，你可以得到一个尚可使用的系统，但你知道，重构之后，它可以更好；当然你也可以选择重构，死着皮，连着肉。</p>
<p>重赏之下，必有卷夫。内部赛还好，外部赛实在是卷，每次这种性能挑战赛，打到最后都是拼了命的抠细节，你被别人卷到了，就很累，你想到了优化点，卷到了别人，就很爽，这也太真实了。</p>
<p>最后说说收获，这次比赛，让我对 AEP 这个新概念有了比较深的理解，对存储设计、文件 IO 也有了更深的体会。这类比赛偶尔打打还是挺有意思的，一方面写项目代码容易疲乏，二是写出这么一个小的工程，还是挺有成就感的一件事。如果有下一场，也欢迎读者们一起来卷。</p>
<h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><p><a target="_blank" rel="noopener" href="https://github.com/lexburner/aliyun-cloudnative-race-mq-2021.git">https://github.com/lexburner/aliyun-cloudnative-race-mq-2021.git</a></p>
</div><div class="article-licensing box"><div class="licensing-title"><p>【参赛总结】第二届云原生编程挑战赛-冷热读写场景的RocketMQ存储系统设计</p><p><a href="https://www.cnkirito.moe/cloudnative-race-2021-rmq/">https://www.cnkirito.moe/cloudnative-race-2021-rmq/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>徐靖峰</p></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2021-11-02</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2025-07-01</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icon" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a><a class="icon" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a><a class="icon" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><hr style="height:1px;margin:1rem 0"><div class="level is-mobile is-flex"><div class="article-tags is-size-7 is-uppercase"><i class="fas fa-tags has-text-grey"></i> <a class="link-muted" rel="tag" href="/tags/%E6%96%87%E4%BB%B6IO/">文件IO </a></div></div><!--!--></article></div><div class="card"><div class="card-content"><h3 class="menu-label has-text-centered">喜欢这篇文章？打赏一下作者吧</h3><div class="buttons is-centered"><a class="button donate" data-type="alipay"><span class="icon is-small"><i class="fab fa-alipay"></i></span><span>支付宝</span><span class="qrcode"><img src="/img/alipay.png" alt="支付宝"></span></a><a class="button donate" data-type="wechat"><span class="icon is-small"><i class="fab fa-weixin"></i></span><span>微信</span><span class="qrcode"><img src="/img/wechatpay.png" alt="微信"></span></a></div></div></div><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/learn-mmap/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">重新认识 Java 中的内存映射（mmap）</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/unsafe-bytebuffer/"><span class="level-item">Unsafe与ByteBuffer那些事</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><!--!--><div><script src="https://readmore.openwrite.cn/js/readmore.js" type="text/javascript"></script>
            <script>
                const btw = new BTWPlugin();
                btw.init({
                    id: "article-content",
                    blogId: '10053-1610820399501-222',
                    name: 'Kirito的技术分享',
                    qrcode: 'http://image.cnkirito.cn/qrcode_for_gh_c06057be7960_258%20%281%29.jpg',
                    keyword: 'more'
                });
                var rm_btn = $('#read-more-btn');
                rm_btn.html('~阅读全文~人机检测~');
            </script>
            </div></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/avatar.png" alt="徐靖峰"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">徐靖峰</p><p class="is-size-6 is-block">阿里巴巴中间件研发</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>中国·杭州</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">177</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">22</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">77</p></a></div></div></nav><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/wechat_public.jpg" alt="Kirito的技术分享"></figure><div class="level"><a class="level-item button is-primary is-rounded" target="_blank" rel="noopener">↑关注微信公众号↑</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/lexburner"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="WeChat" href="/img/wechat_public.jpg"><i class="fab fa-weixin"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="RSS" href="/atom.xml"><i class="fas fa-rss"></i></a></div></div></div><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="level is-mobile" href="#前言"><span class="level-left"><span class="level-item">1</span><span class="level-item">前言</span></span></a></li><li><a class="level is-mobile" href="#参赛历程"><span class="level-left"><span class="level-item">2</span><span class="level-item">参赛历程</span></span></a></li><li><a class="level is-mobile" href="#最终方案"><span class="level-left"><span class="level-item">3</span><span class="level-item">最终方案</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#SSD-写入方案"><span class="level-left"><span class="level-item">3.1</span><span class="level-item">SSD 写入方案</span></span></a></li><li><a class="level is-mobile" href="#缓存架构"><span class="level-left"><span class="level-item">3.2</span><span class="level-item">缓存架构</span></span></a></li></ul></li><li><a class="level is-mobile" href="#程序优化"><span class="level-left"><span class="level-item">4</span><span class="level-item">程序优化</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#预分配文件"><span class="level-left"><span class="level-item">4.1</span><span class="level-item">预分配文件</span></span></a></li><li><a class="level is-mobile" href="#4KB-对齐"><span class="level-left"><span class="level-item">4.2</span><span class="level-item">4KB 对齐</span></span></a></li><li><a class="level is-mobile" href="#Unsafe"><span class="level-left"><span class="level-item">4.3</span><span class="level-item">Unsafe</span></span></a></li><li><a class="level is-mobile" href="#ArrayMap"><span class="level-left"><span class="level-item">4.4</span><span class="level-item">ArrayMap</span></span></a></li><li><a class="level is-mobile" href="#预初始化"><span class="level-left"><span class="level-item">4.5</span><span class="level-item">预初始化</span></span></a></li><li><a class="level is-mobile" href="#并发-getRange"><span class="level-left"><span class="level-item">4.6</span><span class="level-item">并发 getRange</span></span></a></li><li><a class="level is-mobile" href="#ThreadLocal-复用"><span class="level-left"><span class="level-item">4.7</span><span class="level-item">ThreadLocal 复用</span></span></a></li><li><a class="level is-mobile" href="#合并写入"><span class="level-left"><span class="level-item">4.8</span><span class="level-item">合并写入</span></span></a></li><li><a class="level is-mobile" href="#AEP-滑动窗口"><span class="level-left"><span class="level-item">4.9</span><span class="level-item">AEP 滑动窗口</span></span></a></li></ul></li><li><a class="level is-mobile" href="#总结与反思"><span class="level-left"><span class="level-item">5</span><span class="level-item">总结与反思</span></span></a></li><li><a class="level is-mobile" href="#源码"><span class="level-left"><span class="level-item">6</span><span class="level-item">源码</span></span></a></li></ul></div></div><script src="/js/toc.js" defer></script></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/avatar.png" alt="徐靖峰|个人博客" height="28"></a><p class="is-size-7"><span>&copy; 2025 徐靖峰</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><div id="outdated"><h6>Your browser is out-of-date!</h6><p>Update your browser to view this website correctly.&amp;npsb;<a id="btnUpdateBrowser" target="_blank" rel="noopener" href="http://outdatedbrowser.com/">Update my browser now </a></p><p class="last"><a href="#" id="btnCloseUpdateBrowser" title="Close">×</a></p></div><script src="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.js" defer></script><script>window.addEventListener("load", function () {
            outdatedBrowser({
                bgColor: '#f25648',
                color: '#ffffff',
                lowerThan: 'object-fit' // display on IE11 or below
            });
        });</script><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>