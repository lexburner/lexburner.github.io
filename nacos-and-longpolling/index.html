<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>用了这么久配置中心，还不知道长轮询是什么？ - 徐靖峰|个人博客</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="Kirito的技术分享"><meta name="msapplication-TileImage" content="/img/avatar.png"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Kirito的技术分享"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="前言传统的静态配置方式想要修改某个配置时，必须重新启动一次应用，如果是数据库连接串的变更，那可能还容易接受一些，但如果变更的是一些运行时实时感知的配置，如某个功能项的开关，重启应用就显得有点大动干戈了。配置中心正是为了解决此类问题应运而生的，特别是在微服务架构体系中，更倾向于使用配置中心来统一管理配置。 配置中心最核心的能力就是配置的动态推送，常见的配置中心如 Nacos、Apollo 等都实现了"><meta property="og:type" content="blog"><meta property="og:title" content="用了这么久配置中心，还不知道长轮询是什么？"><meta property="og:url" content="https://www.cnkirito.moe/nacos-and-longpolling/"><meta property="og:site_name" content="徐靖峰|个人博客"><meta property="og:description" content="前言传统的静态配置方式想要修改某个配置时，必须重新启动一次应用，如果是数据库连接串的变更，那可能还容易接受一些，但如果变更的是一些运行时实时感知的配置，如某个功能项的开关，重启应用就显得有点大动干戈了。配置中心正是为了解决此类问题应运而生的，特别是在微服务架构体系中，更倾向于使用配置中心来统一管理配置。 配置中心最核心的能力就是配置的动态推送，常见的配置中心如 Nacos、Apollo 等都实现了"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://image.cnkirito.cn/image-20210124145858668.png"><meta property="article:published_time" content="2021-01-23T06:37:39.000Z"><meta property="article:modified_time" content="2025-05-26T03:18:30.984Z"><meta property="article:author" content="徐靖峰"><meta property="article:tag" content="Nacos"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="https://image.cnkirito.cn/image-20210124145858668.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://www.cnkirito.moe/nacos-and-longpolling/"},"headline":"用了这么久配置中心，还不知道长轮询是什么？","image":["https://image.cnkirito.cn/image-20210124145858668.png"],"datePublished":"2021-01-23T06:37:39.000Z","dateModified":"2025-05-26T03:18:30.984Z","author":{"@type":"Person","name":"徐靖峰"},"description":"前言传统的静态配置方式想要修改某个配置时，必须重新启动一次应用，如果是数据库连接串的变更，那可能还容易接受一些，但如果变更的是一些运行时实时感知的配置，如某个功能项的开关，重启应用就显得有点大动干戈了。配置中心正是为了解决此类问题应运而生的，特别是在微服务架构体系中，更倾向于使用配置中心来统一管理配置。 配置中心最核心的能力就是配置的动态推送，常见的配置中心如 Nacos、Apollo 等都实现了"}</script><link rel="canonical" href="https://www.cnkirito.moe/nacos-and-longpolling/"><link rel="icon" href="/img/avatar.png"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.12.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><script src="https://www.googletagmanager.com/gtag/js?id=UA-118574570-1" async></script><script>window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
    
        gtag('config', 'UA-118574570-1');</script><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.css"><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><!--!--><!--!--><meta name="generator" content="Hexo 5.4.0"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/avatar.png" alt="徐靖峰|个人博客" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/.">主页</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/archives">归档</a><a class="navbar-item" href="/about">关于</a><a class="navbar-item" target="_blank" rel="noopener" href="https://github.com/YunaiV/onemall">开源项目</a></div><div class="navbar-end"><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-9-widescreen"><div class="card"><article class="card-content article" id="article-content" role="article"><h1 class="title is-size-3 is-size-4-mobile has-text-weight-semibold article-main-title"><span class="has-text-dark"><i class="fas fa-angle-double-right"></i>用了这么久配置中心，还不知道长轮询是什么？</span></h1><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><i class="far fa-calendar-alt"> </i><time dateTime="${date_xml(page.date)}" title="${date_xml(page.date)}">2021-01-23</time></span><span class="level-item is-hidden-mobile"><i class="far fa-calendar-check"> </i><time dateTime="${date_xml(page.updated)}" title="${date_xml(page.updated)}">2025-05-26</time></span><span class="level-item"><a class="link-muted" href="/categories/Nacos/">Nacos</a></span><span class="level-item">30 分钟读完 (大约4558个字)</span></div></div><div class="content"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>传统的静态配置方式想要修改某个配置时，必须重新启动一次应用，如果是数据库连接串的变更，那可能还容易接受一些，但如果变更的是一些运行时实时感知的配置，如某个功能项的开关，重启应用就显得有点大动干戈了。配置中心正是为了解决此类问题应运而生的，特别是在微服务架构体系中，更倾向于使用配置中心来统一管理配置。</p>
<p>配置中心最核心的能力就是配置的动态推送，常见的配置中心如 Nacos、Apollo 等都实现了这样的能力。在早期接触配置中心时，我就很好奇，配置中心是如何做到服务端感知配置变化实时推送给客户端的，在没有研究过配置中心的实现原理之前，我一度认为配置中心是通过<strong>长连接</strong>来做到配置推送的。事实上，目前比较流行的两款配置中心：Nacos 和 Apollo 恰恰都没有使用<strong>长连接</strong>，而是使用的<strong>长轮询</strong>。本文便是介绍一下长轮询这种听起来好像已经是上个世纪的技术，老戏新唱，看看能不能品出别样的韵味。文中会有代码示例，呈现一个简易的配置监听流程。</p>
<span id="more"></span>

<h2 id="数据交互模式"><a href="#数据交互模式" class="headerlink" title="数据交互模式"></a>数据交互模式</h2><p>众所周知，数据交互有两种模式：Push（推模式）和 Pull（拉模式）。</p>
<p>推模式指的是客户端与服务端建立好网络长连接，服务方有相关数据，直接通过长连接通道推送到客户端。其优点是及时，一旦有数据变更，客户端立马能感知到；另外对客户端来说逻辑简单，不需要关心有无数据这些逻辑处理。缺点是不知道客户端的数据消费能力，可能导致数据积压在客户端，来不及处理。</p>
<p>拉模式指的是客户端主动向服务端发出请求，拉取相关数据。其优点是此过程由客户端发起请求，故不存在推模式中数据积压的问题。缺点是可能不够及时，对客户端来说需要考虑数据拉取相关逻辑，何时去拉，拉的频率怎么控制等等。</p>
<h2 id="长轮询与轮询"><a href="#长轮询与轮询" class="headerlink" title="长轮询与轮询"></a>长轮询与轮询</h2><p>在开头，重点介绍一下长轮询（Long Polling）和轮询（Polling）的区别，两者都是拉模式的实现。</p>
<p>「轮询」是指不管服务端数据有无更新，客户端每隔定长时间请求拉取一次数据，可能有更新数据返回，也可能什么都没有。配置中心如果使用「轮询」实现动态推送，会有以下问题：</p>
<ul>
<li>推送延迟。客户端每隔 5s 拉取一次配置，若配置变更发生在第 6s，则配置推送的延迟会达到 4s。</li>
<li>服务端压力。配置一般不会发生变化，频繁的轮询会给服务端造成很大的压力。</li>
<li>推送延迟和服务端压力无法中和。降低轮询的间隔，延迟降低，压力增加；增加轮询的间隔，压力降低，延迟增高。</li>
</ul>
<p>「长轮询」则不存在上述的问题。客户端发起长轮询，如果服务端的数据没有发生变更，会 hold 住请求，直到服务端的数据发生变化，或者等待一定时间超时才会返回。返回后，客户端又会立即再次发起下一次长轮询。配置中心使用「长轮询」如何解决「轮询」遇到的问题也就显而易见了：</p>
<ul>
<li>推送延迟。服务端数据发生变更后，长轮询结束，立刻返回响应给客户端。</li>
<li>服务端压力。长轮询的间隔期一般很长，例如 30s、60s，并且服务端 hold 住连接不会消耗太多服务端资源。</li>
</ul>
<p>以 Nacos 为例的长轮询流程如下：</p>
<p><img src="https://image.cnkirito.cn/image-20210124145858668.png" alt="nacos long polling"></p>
<p>可能有人会有疑问，为什么一次长轮询需要等待一定时间超时，超时后又发起长轮询，为什么不让服务端一直 hold 住？主要有两个层面的考虑，一是连接稳定性的考虑，长轮询在传输层本质上还是走的 TCP 协议，如果服务端假死、fullgc 等异常问题，或者是重启等常规操作，长轮询没有应用层的心跳机制，仅仅依靠 TCP 层的心跳保活很难确保可用性，所以一次长轮询设置一定的超时时间也是在确保可用性。除此之外，在配置中心场景，还有一定的业务需求需要这么设计。在配置中心的使用过程中，用户可能随时新增配置监听，而在此之前，长轮询可能已经发出，新增的配置监听无法包含在旧的长轮询中，所以在配置中心的设计中，一般会在一次长轮询结束后，将新增的配置监听给捎带上，而如果长轮询没有超时时间，只要配置一直不发生变化，响应就无法返回，新增的配置也就没法设置监听了。</p>
<h2 id="配置中心长轮询设计"><a href="#配置中心长轮询设计" class="headerlink" title="配置中心长轮询设计"></a>配置中心长轮询设计</h2><p>上文的图中，介绍了长轮询的流程，本节会详解配置中心长轮询的设计细节。</p>
<ul>
<li><p>客户端发起长轮询</p>
<p>客户端发起一个 HTTP 请求，请求信息包含配置中心的地址，以及监听的 dataId（本文出于简化说明的考虑，认为 dataId 是定位配置的唯一键）。若配置没有发生变化，客户端与服务端之间一直处于连接状态。</p>
</li>
<li><p>服务端监听数据变化</p>
<p>服务端会维护 dataId 和长轮询的映射关系，如果配置发生变化，服务端会找到对应的连接，为响应写入更新后的配置内容。如果超时内配置未发生变化，服务端找到对应的超时长轮询连接，写入 304 响应。</p>
<blockquote>
<p>304 在 HTTP 响应码中代表“未改变”，并不代表错误。比较契合长轮询时，配置未发生变更的场景。</p>
</blockquote>
</li>
<li><p>客户端接收长轮询响应</p>
<p>首先查看响应码是 200 还是 304，以判断配置是否变更，做出相应的回调。之后再次发起下一次长轮询。</p>
</li>
<li><p>服务端设置配置写入的接入点</p>
<p>主要用配置控制台和 client 发布配置，触发配置变更</p>
</li>
</ul>
<p>这几点便是配置中心实现长轮询的核心步骤，也是指导下面章节代码实现的关键。但在编码之前，仍有一些其他的注意点需要实现阐明。</p>
<p>配置中心往往是为分布式的集群提供服务的，而每个机器上部署的应用，又会有多个 dataId 需要监听，实例级别 * 配置数是一个不小的数字，配置中心服务端维护这些 dataId 的长轮询连接显然不能用线程一一对应，否则会导致服务端线程数爆炸式增长。一个 Tomcat 也就 200 个线程，长轮询也不应该阻塞 Tomcat 的业务线程，所以需要配置中心在实现长轮询时，往往采用异步响应的方式来实现。而比较方便实现异步 HTTP 的常见手段便是 Servlet3.0 提供的 AsyncContext 机制。</p>
<blockquote>
<p>Servlet3.0 并不是一个特别新的规范，它跟 Java 6 是同一时期的产物。例如 SpringBoot 内嵌的 Tomcat 很早就支持了 Servlet3.0，你无需担心 AsyncContext 机制不起作用。</p>
</blockquote>
<p>SpringMVC 实现了 DeferredResult 和 Servlet3.0 提供的 AsyncContext 其实没有多大区别，我并没有深入研究过两个实现背后的源码，但从使用层面上来看，AsyncContext 更加的灵活，例如其可以自定义响应码，而 DeferredResult 在上层做了封装，可以快速的帮助开发者实现一个异步响应，但没法细粒度地控制响应。所以下文的示例中，我选择了 AsyncContext。</p>
<h2 id="配置中心长轮询实现"><a href="#配置中心长轮询实现" class="headerlink" title="配置中心长轮询实现"></a>配置中心长轮询实现</h2><h3 id="客户端实现"><a href="#客户端实现" class="headerlink" title="客户端实现"></a>客户端实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> CloseableHttpClient httpClient;</span><br><span class="line">    <span class="keyword">private</span> RequestConfig requestConfig;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConfigClient</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.httpClient = HttpClientBuilder.create().build();</span><br><span class="line">        <span class="comment">// ① httpClient 客户端超时时间要大于长轮询约定的超时时间</span></span><br><span class="line">        <span class="keyword">this</span>.requestConfig = RequestConfig.custom().setSocketTimeout(<span class="number">40000</span>).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SneakyThrows</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">longPolling</span><span class="params">(String url, String dataId)</span> </span>&#123;</span><br><span class="line">        String endpoint = url + <span class="string">&quot;?dataId=&quot;</span> + dataId;</span><br><span class="line">        HttpGet request = <span class="keyword">new</span> HttpGet(endpoint);</span><br><span class="line">        CloseableHttpResponse response = httpClient.execute(request);</span><br><span class="line">        <span class="keyword">switch</span> (response.getStatusLine().getStatusCode()) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">200</span>: &#123;</span><br><span class="line">                BufferedReader rd = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(response.getEntity()</span><br><span class="line">                    .getContent()));</span><br><span class="line">                StringBuilder result = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">                String line;</span><br><span class="line">                <span class="keyword">while</span> ((line = rd.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    result.append(line);</span><br><span class="line">                &#125;</span><br><span class="line">                response.close();</span><br><span class="line">                String configInfo = result.toString();</span><br><span class="line">                log.info(<span class="string">&quot;dataId: [&#123;&#125;] changed, receive configInfo: &#123;&#125;&quot;</span>, dataId, configInfo);</span><br><span class="line">                longPolling(url, dataId);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// ② 304 响应码标记配置未变更</span></span><br><span class="line">            <span class="keyword">case</span> <span class="number">304</span>: &#123;</span><br><span class="line">                log.info(<span class="string">&quot;longPolling dataId: [&#123;&#125;] once finished, configInfo is unchanged, longPolling again&quot;</span>, dataId);</span><br><span class="line">                longPolling(url, dataId);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">default</span>: &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;unExcepted HTTP status code&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// httpClient 会打印很多 debug 日志，关闭掉</span></span><br><span class="line">        Logger logger = (Logger)LoggerFactory.getLogger(<span class="string">&quot;org.apache.http&quot;</span>);</span><br><span class="line">        logger.setLevel(Level.INFO);</span><br><span class="line">        logger.setAdditive(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        ConfigClient configClient = <span class="keyword">new</span> ConfigClient();</span><br><span class="line">        <span class="comment">// ③ 对 dataId: user 进行配置监听 </span></span><br><span class="line">        configClient.longPolling(<span class="string">&quot;http://127.0.0.1:8080/listener&quot;</span>, <span class="string">&quot;user&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主要有三个注意点：</p>
<ul>
<li><code>RequestConfig.custom().setSocketTimeout(40000).build()</code> 。httpClient 客户端超时时间要大于长轮询约定的超时时间。很好理解，不然还没等服务端返回，客户端会自行断开 HTTP 连接。</li>
<li><code>response.getStatusLine().getStatusCode() == 304</code> 。前文介绍过，约定使用 304 响应码来标识配置未发生变更，客户端继续发起长轮询。</li>
<li><code>configClient.longPolling(&quot;http://127.0.0.1:8080/listener&quot;, &quot;user&quot;)</code>。在示例中，我们处于简单考虑，仅仅启动一个客户端，对单一的 dataId：user 进行监听（注意，需要先启动 server 端）。</li>
</ul>
<h3 id="服务端实现"><a href="#服务端实现" class="headerlink" title="服务端实现"></a>服务端实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Data</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncTask</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 长轮询请求的上下文，包含请求和响应体</span></span><br><span class="line">        <span class="keyword">private</span> AsyncContext asyncContext;</span><br><span class="line">        <span class="comment">// 超时标记</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">boolean</span> timeout;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">AsyncTask</span><span class="params">(AsyncContext asyncContext, <span class="keyword">boolean</span> timeout)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.asyncContext = asyncContext;</span><br><span class="line">            <span class="keyword">this</span>.timeout = timeout;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// guava 提供的多值 Map，一个 key 可以对应多个 value</span></span><br><span class="line">    <span class="keyword">private</span> Multimap&lt;String, AsyncTask&gt; dataIdContext = Multimaps.synchronizedSetMultimap(HashMultimap.create());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ThreadFactory threadFactory = <span class="keyword">new</span> ThreadFactoryBuilder().setNameFormat(<span class="string">&quot;longPolling-timeout-checker-%d&quot;</span>)</span><br><span class="line">        .build();</span><br><span class="line">    <span class="keyword">private</span> ScheduledExecutorService timeoutChecker = <span class="keyword">new</span> ScheduledThreadPoolExecutor(<span class="number">1</span>, threadFactory);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 配置监听接入点</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/listener&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addListener</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        String dataId = request.getParameter(<span class="string">&quot;dataId&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 开启异步</span></span><br><span class="line">        AsyncContext asyncContext = request.startAsync(request, response);</span><br><span class="line">        AsyncTask asyncTask = <span class="keyword">new</span> AsyncTask(asyncContext, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 维护 dataId 和异步请求上下文的关联</span></span><br><span class="line">        dataIdContext.put(dataId, asyncTask);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 启动定时器，30s 后写入 304 响应</span></span><br><span class="line">        timeoutChecker.schedule(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (asyncTask.isTimeout()) &#123;</span><br><span class="line">                dataIdContext.remove(dataId, asyncTask);</span><br><span class="line">                response.setStatus(HttpServletResponse.SC_NOT_MODIFIED);</span><br><span class="line">                asyncContext.complete();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="number">30000</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 配置发布接入点</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/publishConfig&quot;)</span></span><br><span class="line">    <span class="meta">@SneakyThrows</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">publishConfig</span><span class="params">(String dataId, String configInfo)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;publish configInfo dataId: [&#123;&#125;], configInfo: &#123;&#125;&quot;</span>, dataId, configInfo);</span><br><span class="line">        Collection&lt;AsyncTask&gt; asyncTasks = dataIdContext.removeAll(dataId);</span><br><span class="line">        <span class="keyword">for</span> (AsyncTask asyncTask : asyncTasks) &#123;</span><br><span class="line">            asyncTask.setTimeout(<span class="keyword">false</span>);</span><br><span class="line">            HttpServletResponse response = (HttpServletResponse)asyncTask.getAsyncContext().getResponse();</span><br><span class="line">            response.setStatus(HttpServletResponse.SC_OK);</span><br><span class="line">            response.getWriter().println(configInfo);</span><br><span class="line">            asyncTask.getAsyncContext().complete();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(ConfigServer.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对上述实现的一些说明：</p>
<p><code>@RequestMapping(&quot;/listener&quot;)</code> ，配置监听接入点，也是长轮询的入口。在获取 dataId 之后，使用 <code>request.startAsync</code> 将请求设置为异步，这样在方法结束后，不会占用 Tomcat 的线程池。</p>
<p>接着 <code>dataIdContext.put(dataId, asyncTask) </code> 会将 dataId 和异步请求上下文给关联起来，方便配置发布时，拿到对应的上下文。注意这里使用了一个 guava 提供的数据结构 <code>Multimap&lt;String, AsyncTask&gt; dataIdContext</code> ，它是一个多值 Map，一个 key 可以对应多个 value，你也可以理解为 <code>Map&lt;String,List&lt;AsyncTask&gt;&gt;</code> ，但使用 <code>Multimap</code> 维护起来可以更方便地处理一些并发逻辑。至于为什么会有多值，很好理解，因为配置中心的 Server 端会接受来自多个客户端对同一个 dataId 的监听。</p>
<p><code>timeoutChecker.schedule()</code> 启动定时器，30s 后写入 304 响应。再结合之前客户端的逻辑，接收到 304 之后，会重新发起长轮询，形成一个循环。</p>
<p><code>@RequestMapping(&quot;/publishConfig&quot;)</code> ，配置发布的入口。配置变更后，根据 dataId 一次拿出所有的长轮询，为之写入变更的响应，同时不要忘记取消定时任务。至此，完成了一个配置变更后推送的流程。</p>
<h3 id="启动配置监听"><a href="#启动配置监听" class="headerlink" title="启动配置监听"></a>启动配置监听</h3><p>先启动 ConfigServer，再启动 ConfigClient。客户端打印长轮询的日志如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">22:18:09.185 [main] INFO moe.cnkirito.demo.ConfigClient - longPolling dataId: [user] once finished, configInfo is unchanged, longPolling again</span><br><span class="line">22:18:39.197 [main] INFO moe.cnkirito.demo.ConfigClient - longPolling dataId: [user] once finished, configInfo is unchanged, longPolling again</span><br></pre></td></tr></table></figure>

<p>发布一条配置，<code>curl -X GET &quot;localhost:8080/publishConfig?dataId=user&amp;configInfo=helloworld&quot;</code></p>
<p>服务端打印日志如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2021-01-24 22:18:50.801  INFO 73301 --- [nio-8080-exec-6] moe.cnkirito.demo.ConfigServer           : publish configInfo dataId: [user], configInfo: helloworld</span><br></pre></td></tr></table></figure>

<p>客户端接受配置推送：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">22:18:50.806 [main] INFO moe.cnkirito.demo.ConfigClient - dataId: [user] changed, receive configInfo: helloworld</span><br></pre></td></tr></table></figure>

<h2 id="实现细节思考"><a href="#实现细节思考" class="headerlink" title="实现细节思考"></a>实现细节思考</h2><h3 id="为什么需要定时器返回-304"><a href="#为什么需要定时器返回-304" class="headerlink" title="为什么需要定时器返回 304"></a>为什么需要定时器返回 304</h3><p>上述的实现中，服务端采用了一个定时器，在配置未发生变更时，定时返回 304，客户端接收到 304 之后，重新发起长轮询。在前文，已经解释过了为什么需要超时后重新发起长轮询，而不是由服务端一直 hold，直到配置变更再返回，但可能有读者还会有疑问，为什么不由客户端控制超时，服务端去除掉定时器，这样客户端超时后重新发起下一次长轮询，这样的设计不是更简单吗？无论是 Nacos 还是 Apollo 都有这样的定时器，而不是靠客户端控制超时，这样做主要有两点考虑：</p>
<ul>
<li>和真正的客户端超时区分开。</li>
<li>仅仅使用异常（Exception）来表达异常流，而不应该用异常来表达正常的业务流。304 不是超时异常，而是长轮询中配置未变更的一种正常流程，不应该使用超时异常来表达。</li>
</ul>
<p>客户端超时需要单独配置，且需要比服务端长轮询的超时要长。正如上述的 demo 中客户端超时设置的是 40s，服务端判断一次长轮询超时是 30s。这两个值在 Nacos 中默认是 30s 和 29.5s，在 Apollo 中默认是是 90s 和 60s。 </p>
<h3 id="长轮询包含多组-dataId"><a href="#长轮询包含多组-dataId" class="headerlink" title="长轮询包含多组 dataId"></a>长轮询包含多组 dataId</h3><p>在上述的 demo 中，一个 dataId 会发起一次长轮询，在实际配置中心的设计中肯定不能这样设计，一般的优化方式是，一批 dataId 组成一个组批量包含在一个长轮询任务中。在 Nacos 中，按照 3000 个 dataId 为一组包装成一个长轮询任务。</p>
<h2 id="长轮询和长连接"><a href="#长轮询和长连接" class="headerlink" title="长轮询和长连接"></a>长轮询和长连接</h2><p>讲完实现细节，本文最核心的部分已经介绍完了。再回到最前面提到的数据交互模式上提到的推模型和拉模型，其实在写这篇文章时，我曾经问过交流群中的小伙伴们“配置中心实现动态推送的原理”，他们中绝大多数人认为是长连接的推模型。然而事实上，主流的配置中心几乎都是使用了本文介绍的长轮询方案，这又是为什么呢？</p>
<p>我也翻阅了不少博客，显然他们给出的理由并不能说服我，我尝试着从自己的角度分析了一下这个既定的事实。</p>
<ol>
<li>长轮询实现起来比较容易，完全依赖于 HTTP 便可以实现全部逻辑，而 HTTP 是最能够被大众接受的通信方式。</li>
<li>长轮询使用 HTTP，便于多语言客户端的编写，大多数语言都有 HTTP 的客户端。</li>
</ol>
<p>那么长连接是不是真的就不适合用于配置中心场景呢？有人可能会认为维护一条长连接会消耗大量资源，而长轮询可以提升系统的吞吐量，而在配置中心场景，这一假设并没有实际的压测数据能够论证，benchmark everything！please~</p>
<p>另外，翻阅了一下 Nacos 2.0 的 milestone，我发现了一个有意思的规划，Nacos 的注册中心（目前是短轮询 + udp 推送）和配置中心（目前是长轮询）都有计划改造为长连接模式。</p>
<p>再回过头来看，长轮询实现已经将配置中心这个组件支撑的足够好了，替换成长连接，一定需要找到合适的理由才行。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li>本文介绍了长轮询、轮询、长连接这几种数据交互模型的差异性。</li>
<li>分析了 Nacos 和 Apollo 等主流配置中心均是通过长轮询的方式实现配置的实时推送的。实时感知建立在客户端拉的基础上，因为本质上还是通过 HTTP 进行的数据交互，之所以有“推”的感觉，是因为服务端 hold 住了客户端的响应体，并且在配置变更后主动写入了返回 response 对象再进行返回。</li>
<li>通过一个简单的 demo，实现了长轮询配置实时推送的过程演示，本文的 demo 示例存放在：<a target="_blank" rel="noopener" href="https://github.com/lexburner/longPolling-demo">https://github.com/lexburner/longPolling-demo</a></li>
</ol>
</div><div class="article-licensing box"><div class="licensing-title"><p>用了这么久配置中心，还不知道长轮询是什么？</p><p><a href="https://www.cnkirito.moe/nacos-and-longpolling/">https://www.cnkirito.moe/nacos-and-longpolling/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>徐靖峰</p></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2021-01-23</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2025-05-26</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icon" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a><a class="icon" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a><a class="icon" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><hr style="height:1px;margin:1rem 0"><div class="level is-mobile is-flex"><div class="article-tags is-size-7 is-uppercase"><i class="fas fa-tags has-text-grey"></i> <a class="link-muted" rel="tag" href="/tags/Nacos/">Nacos </a></div></div><!--!--></article></div><div class="card"><div class="card-content"><h3 class="menu-label has-text-centered">喜欢这篇文章？打赏一下作者吧</h3><div class="buttons is-centered"><a class="button donate" data-type="alipay"><span class="icon is-small"><i class="fab fa-alipay"></i></span><span>支付宝</span><span class="qrcode"><img src="/img/alipay.png" alt="支付宝"></span></a><a class="button donate" data-type="wechat"><span class="icon is-small"><i class="fab fa-weixin"></i></span><span>微信</span><span class="qrcode"><img src="/img/wechatpay.png" alt="微信"></span></a></div></div></div><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/school-internship/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">从校园到职场，聊聊实习这点事</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/dubbo-nacos-registry/"><span class="level-item">Dubbo 基础教程：使用 Nacos 实现服务注册与发现</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><!--!--></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/avatar.png" alt="徐靖峰"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">徐靖峰</p><p class="is-size-6 is-block">阿里巴巴中间件研发</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>中国·杭州</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">180</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">14</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">77</p></a></div></div></nav><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/wechat_public.jpg" alt="Kirito的技术分享"></figure><div class="level"><a class="level-item button is-primary is-rounded" target="_blank" rel="noopener">↑关注微信公众号↑</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/lexburner"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="WeChat" href="/img/wechat_public.jpg"><i class="fab fa-weixin"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="RSS" href="/atom.xml"><i class="fas fa-rss"></i></a></div></div></div><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="level is-mobile" href="#前言"><span class="level-left"><span class="level-item">1</span><span class="level-item">前言</span></span></a></li><li><a class="level is-mobile" href="#数据交互模式"><span class="level-left"><span class="level-item">2</span><span class="level-item">数据交互模式</span></span></a></li><li><a class="level is-mobile" href="#长轮询与轮询"><span class="level-left"><span class="level-item">3</span><span class="level-item">长轮询与轮询</span></span></a></li><li><a class="level is-mobile" href="#配置中心长轮询设计"><span class="level-left"><span class="level-item">4</span><span class="level-item">配置中心长轮询设计</span></span></a></li><li><a class="level is-mobile" href="#配置中心长轮询实现"><span class="level-left"><span class="level-item">5</span><span class="level-item">配置中心长轮询实现</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#客户端实现"><span class="level-left"><span class="level-item">5.1</span><span class="level-item">客户端实现</span></span></a></li><li><a class="level is-mobile" href="#服务端实现"><span class="level-left"><span class="level-item">5.2</span><span class="level-item">服务端实现</span></span></a></li><li><a class="level is-mobile" href="#启动配置监听"><span class="level-left"><span class="level-item">5.3</span><span class="level-item">启动配置监听</span></span></a></li></ul></li><li><a class="level is-mobile" href="#实现细节思考"><span class="level-left"><span class="level-item">6</span><span class="level-item">实现细节思考</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#为什么需要定时器返回-304"><span class="level-left"><span class="level-item">6.1</span><span class="level-item">为什么需要定时器返回 304</span></span></a></li><li><a class="level is-mobile" href="#长轮询包含多组-dataId"><span class="level-left"><span class="level-item">6.2</span><span class="level-item">长轮询包含多组 dataId</span></span></a></li></ul></li><li><a class="level is-mobile" href="#长轮询和长连接"><span class="level-left"><span class="level-item">7</span><span class="level-item">长轮询和长连接</span></span></a></li><li><a class="level is-mobile" href="#总结"><span class="level-left"><span class="level-item">8</span><span class="level-item">总结</span></span></a></li></ul></div></div><script src="/js/toc.js" defer></script></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/avatar.png" alt="徐靖峰|个人博客" height="28"></a><p class="is-size-7"><span>&copy; 2026 徐靖峰</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><div id="outdated"><h6>Your browser is out-of-date!</h6><p>Update your browser to view this website correctly.&amp;npsb;<a id="btnUpdateBrowser" target="_blank" rel="noopener" href="http://outdatedbrowser.com/">Update my browser now </a></p><p class="last"><a href="#" id="btnCloseUpdateBrowser" title="Close">×</a></p></div><script src="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.js" defer></script><script>window.addEventListener("load", function () {
            outdatedBrowser({
                bgColor: '#f25648',
                color: '#ffffff',
                lowerThan: 'object-fit' // display on IE11 or below
            });
        });</script><!--!--><!--!--><!--!--><script src="/js/scroll-animations.js" defer></script><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>