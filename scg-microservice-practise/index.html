<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>SpringCloud Gateway 在微服务架构下的最佳实践 - 徐靖峰|个人博客</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="Kirito的技术分享"><meta name="msapplication-TileImage" content="/img/avatar.png"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Kirito的技术分享"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="前言本文整理自云原生技术实践营广州站 Meetup 的分享，其中的经验来自于我们团队开发的阿里云 CSB 2.0 这款产品，这是一款基于开源 SpringCloud Gateway 为 code base 开发的产品，在完全兼容开源用法的前提下，做了非常多企业级的改造，涉及功能特性、稳定性、安全、性能等方面。 为什么需要微服务网关 从功能角度来看，微服务网关通常用来统一提供认证授权、限流、熔断、协"><meta property="og:type" content="blog"><meta property="og:title" content="SpringCloud Gateway 在微服务架构下的最佳实践"><meta property="og:url" content="https://www.cnkirito.moe/scg-microservice-practise/"><meta property="og:site_name" content="徐靖峰|个人博客"><meta property="og:description" content="前言本文整理自云原生技术实践营广州站 Meetup 的分享，其中的经验来自于我们团队开发的阿里云 CSB 2.0 这款产品，这是一款基于开源 SpringCloud Gateway 为 code base 开发的产品，在完全兼容开源用法的前提下，做了非常多企业级的改造，涉及功能特性、稳定性、安全、性能等方面。 为什么需要微服务网关 从功能角度来看，微服务网关通常用来统一提供认证授权、限流、熔断、协"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://image.cnkirito.cn/image-20230707150927224.png"><meta property="og:image" content="https://image.cnkirito.cn/image-20230707154150984.png"><meta property="og:image" content="https://image.cnkirito.cn/image-20230712113239721.png"><meta property="og:image" content="https://image.cnkirito.cn/image-20230712115531910.png"><meta property="og:image" content="https://image.cnkirito.cn/image-20230712115545924.png"><meta property="og:image" content="https://image.cnkirito.cn/image-20230714161600920.png"><meta property="og:image" content="https://image.cnkirito.cn/image-20230714161955374.png"><meta property="og:image" content="https://image.cnkirito.cn/image-20230714164248026.png"><meta property="og:image" content="https://image.cnkirito.cn/image-20230714171525533.png"><meta property="og:image" content="https://image.cnkirito.cn/image-20230714175044775.png"><meta property="og:image" content="https://image.cnkirito.cn/image-20230717135729732.png"><meta property="og:image" content="https://image.cnkirito.cn/image-20230717144227071.png"><meta property="og:image" content="https://image.cnkirito.cn/image-20230717144324186.png"><meta property="article:published_time" content="2023-07-07T06:48:34.000Z"><meta property="article:modified_time" content="2025-12-22T06:40:52.539Z"><meta property="article:author" content="徐靖峰"><meta property="article:tag" content="Spring Cloud Gateway"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="https://image.cnkirito.cn/image-20230707150927224.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://www.cnkirito.moe/scg-microservice-practise/"},"headline":"SpringCloud Gateway 在微服务架构下的最佳实践","image":["https://image.cnkirito.cn/image-20230707150927224.png","https://image.cnkirito.cn/image-20230707154150984.png","https://image.cnkirito.cn/image-20230712113239721.png","https://image.cnkirito.cn/image-20230712115531910.png","https://image.cnkirito.cn/image-20230712115545924.png","https://image.cnkirito.cn/image-20230714161600920.png","https://image.cnkirito.cn/image-20230714161955374.png","https://image.cnkirito.cn/image-20230714164248026.png","https://image.cnkirito.cn/image-20230714171525533.png","https://image.cnkirito.cn/image-20230714175044775.png","https://image.cnkirito.cn/image-20230717135729732.png","https://image.cnkirito.cn/image-20230717144227071.png","https://image.cnkirito.cn/image-20230717144324186.png"],"datePublished":"2023-07-07T06:48:34.000Z","dateModified":"2025-12-22T06:40:52.539Z","author":{"@type":"Person","name":"徐靖峰"},"description":"前言本文整理自云原生技术实践营广州站 Meetup 的分享，其中的经验来自于我们团队开发的阿里云 CSB 2.0 这款产品，这是一款基于开源 SpringCloud Gateway 为 code base 开发的产品，在完全兼容开源用法的前提下，做了非常多企业级的改造，涉及功能特性、稳定性、安全、性能等方面。 为什么需要微服务网关 从功能角度来看，微服务网关通常用来统一提供认证授权、限流、熔断、协"}</script><link rel="canonical" href="https://www.cnkirito.moe/scg-microservice-practise/"><link rel="icon" href="/img/avatar.png"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.12.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><script src="https://www.googletagmanager.com/gtag/js?id=UA-118574570-1" async></script><script>window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
    
        gtag('config', 'UA-118574570-1');</script><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.css"><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><!--!--><!--!--><meta name="generator" content="Hexo 5.4.0"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/avatar.png" alt="徐靖峰|个人博客" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/.">主页</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/archives">归档</a><a class="navbar-item" href="/about">关于</a><a class="navbar-item" target="_blank" rel="noopener" href="https://github.com/YunaiV/onemall">开源项目</a></div><div class="navbar-end"><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-9-widescreen"><div class="card"><article class="card-content article" id="article-content" role="article"><h1 class="title is-size-3 is-size-4-mobile has-text-weight-semibold article-main-title"><span class="has-text-dark"><i class="fas fa-angle-double-right"></i>SpringCloud Gateway 在微服务架构下的最佳实践</span></h1><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><i class="far fa-calendar-alt"> </i><time dateTime="${date_xml(page.date)}" title="${date_xml(page.date)}">2023-07-07</time></span><span class="level-item is-hidden-mobile"><i class="far fa-calendar-check"> </i><time dateTime="${date_xml(page.updated)}" title="${date_xml(page.updated)}">2025-12-22</time></span><span class="level-item"><a class="link-muted" href="/categories/%E7%BD%91%E5%85%B3/">网关</a></span><span class="level-item">37 分钟读完 (大约5560个字)</span></div></div><div class="content"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文整理自云原生技术实践营广州站 Meetup 的分享，其中的经验来自于我们团队开发的阿里云 CSB 2.0 这款产品，这是一款基于开源 SpringCloud Gateway 为 code base 开发的产品，在完全兼容开源用法的前提下，做了非常多企业级的改造，涉及功能特性、稳定性、安全、性能等方面。</p>
<h2 id="为什么需要微服务网关"><a href="#为什么需要微服务网关" class="headerlink" title="为什么需要微服务网关"></a>为什么需要微服务网关</h2><p><img src="https://image.cnkirito.cn/image-20230707150927224.png" alt="网关流量"></p>
<p>从功能角度来看，微服务网关通常用来统一提供认证授权、限流、熔断、协议转换等功能。</p>
<p>从使用场景上来看</p>
<ul>
<li>南北向流量，需要流量网关和微服务网关配合使用，主要是为了区分外部流量和微服务流量，将内部的微服务能力，以统一的 HTTP 接入点对外提供服务</li>
<li>东西向流量，在一些业务量比较大的系统中，可能会按照业务域隔离出一系列的微服务，在同一业务域内的微服务通信走的是服务发现机制，而跨业务域访问，则建议借助于微服务网关。</li>
</ul>
<span id="more"></span>

<h2 id="微服务网关核心功能"><a href="#微服务网关核心功能" class="headerlink" title="微服务网关核心功能"></a>微服务网关核心功能</h2><p>微服务架构、微服务/API 网关这些关键词发展至今，早已不是什么新鲜的概念，技术选型者也从出于好奇心关注一个技术，转移到了更加关注这个技术的本质。市场上各类网关产品的功能也逐渐趋于同质化，基本可以用同一张图来概括：</p>
<p><img src="https://image.cnkirito.cn/image-20230707154150984.png" alt="网关核心功能"></p>
<h2 id="网关选型对比"><a href="#网关选型对比" class="headerlink" title="网关选型对比"></a>网关选型对比</h2><p>企业在选择使用一款网关产品时，通常会有两个选择，一是基于某一款开源产品做二次开发，二是选择某一款商业化产品开箱即用，无论如何，都应当从稳定性、安全、性能、业务兼容性等方面去进行选型。请相信我今天是站在 SpringCloud Gateway 角度进行的分享，我会尽可能做到客观、公正。</p>
<p>早期 SpringCloud 社区出现过 Zuul 这种产品，时至今日搜索微服务网关的资料，大概率都会出现它的身影，仅其通信模型是同步的线程模型这一条，就不足以支撑其成为企业级的网关产品选型，我会主要对比 SpringCloud Gateway、阿里云 CSB 2.0、Nginx、Kong、Envoy。</p>
<p><img src="https://image.cnkirito.cn/image-20230712113239721.png" alt="选型对比"></p>
<p>严谨来说，这几个网关并不适合对比，因为他们都有其各自适用的场景，表格仅供参考。</p>
<p>SpringCloud Gateway 的优势在于其可以很好地跟 Spring 社区和 SpringCloud 微服务体系打通，这一点跟 Java 语言流行的原因如出一辙，所以如果一个企业的语言体系是 Java 技术栈，并且基于 SpringBoot/ SpringCloud 开发微服务，选型 SpringCloud Gateway 作为微服务网关，会有着得天独厚的优势。</p>
<p>SpringCloud Gateway 选型的优势：</p>
<ul>
<li><p>SpringCloud Gateway 有很多开箱即用的功能，且扩展点多</p>
</li>
<li><p>适合 Java 技术栈</p>
</li>
<li><p>Spring/SpringCloud 社区生态好</p>
</li>
<li><p>适合跟 SpringBoot/ SpringCloud 微服务生态集成</p>
</li>
</ul>
<h2 id="SpringCloud-Gateway-介绍"><a href="#SpringCloud-Gateway-介绍" class="headerlink" title="SpringCloud Gateway 介绍"></a>SpringCloud Gateway 介绍</h2><p>如果你之前没有了解过 SpringCloud Gateway，也不用担心，下面一小部分篇幅会介绍 SpringCloud Gateway 基本用法。这是一段非常基础的 SpringCloud Gateway 路由配置示例</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">aliyun</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">https://www.aliyun.com</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Host=*.aliyun.com</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">httpbin</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">http://httpbin.org</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/httpbin/**</span></span><br><span class="line">          <span class="attr">filters:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">StripPrefix=1</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">sca-provider</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">lb://sca-provider</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/sca/**</span></span><br><span class="line">          <span class="attr">filters:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">StripPrefix=1</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="string">mse-xxxxx-p.nacos-ans.mse.aliyuncs.com:8848</span></span><br></pre></td></tr></table></figure>

<p>该示例介绍了微服务网关常见的几种路由配置示例</p>
<ul>
<li>Host 路由匹配</li>
<li>前缀 Path 路由匹配</li>
<li>前缀 Path 路由匹配 &amp; 服务发现</li>
</ul>
<p>SpringCloud Gateway 支持丰富的路由匹配逻辑，以应对各种类型的业务诉求：</p>
<p><img src="https://image.cnkirito.cn/image-20230712115531910.png" alt="SCG断言"></p>
<p>其中 Path、Header、Method 这几种断言最为常用。</p>
<p>针对于网关请求路径、参数和后端服务请求路径、参数不一致的场景，SpringCloud Gateway 也提供了诸多开箱即用的 GatewayFilter，以实现对请求和响应的定制。</p>
<p><img src="https://image.cnkirito.cn/image-20230712115545924.png" alt="SCG插件"></p>
<p>SpringCloud Gateway 的 user guide 介绍到此为止，如果想要了解 develop guide，建议参考 SpringCloud Gateway 的官方文档。</p>
<h2 id="开源特性-vs-企业级特性需求"><a href="#开源特性-vs-企业级特性需求" class="headerlink" title="开源特性 vs 企业级特性需求"></a>开源特性 vs 企业级特性需求</h2><p>众所周知，开源产品直接投入企业级生产使用一般是会面临一些挑战的，毕竟场景不同。以扩展性为例，开源产品大多讲究扩展点丰富，以应对开源用户千奇百怪的需求，而企业级产品场景更为单一，性能和稳定性是第一考虑因素，当二者发生 trade off 时，则需要一些取舍了。</p>
<p><img src="https://image.cnkirito.cn/image-20230714161600920.png" alt="企业级特性"></p>
<p>开源 SpringCloud Gateway 没有开箱即用地支持一些重要的企业级特性，如果选型 SpringCloud Gateway 构建生产级别可用的微服务网关，那我的建议是需要补足以上这些能力。下面我会花较多的篇幅介绍我们在开源基础上做的一些企业级改造，希望能够抛砖引玉。</p>
<h3 id="白屏化管控"><a href="#白屏化管控" class="headerlink" title="白屏化管控"></a>白屏化管控</h3><p><img src="https://image.cnkirito.cn/image-20230714161955374.png" alt="白屏化"></p>
<p>表面看来，SpringCloud Gateway 并没有配套一个管理控制台，深层次一点来看，是 SpringCloud Gateway 还停留在一个开发框架层面，不是那么的产品化，同时它的领域模型也不是划分的那么清晰，说的好听点，这说明 SpringCloud Gateway 有充足的改造空间。</p>
<p>我们的改造原则有两点，一是完全兼容开源的规则及模型，不破坏底层规则的语义，这样我们可以跟随社区的节奏一起演进，将来也有机会贡献给社区，二是区分研发态的领域模型和用户态的产品模型，我们抽象出了路由、服务、来源、消费者、策略、插件等领域对象，这算不上什么创新，实际上网关领域的这些模型早已有了一些约定俗成的规范。</p>
<p>白屏化管控的背后，也意味着一切配置：路由配置、服务配置、策略配置…都是动态的，并且配置的变更都会实时生效。</p>
<h3 id="配置方案重构"><a href="#配置方案重构" class="headerlink" title="配置方案重构"></a>配置方案重构</h3><p>上文提到了配置实时生效这一改造，有人可能会有疑问，开源不是已经支持将路由配置存储在 Nacos 中了吗？对的，开源支持两种配置方式，一是将路由配置在 application.yaml 中，这样最简单，但对于路由配置的 curd 都需要重启进程，非常繁琐，二是将配置托管到 Nacos 这样的配置中心组件中，实现分布式配置，能够动态刷新，但我们认为这还不足以支持企业级需求，将配置存储在单个 dataId 中这种开源方案有以下痛点：</p>
<ol>
<li>配置推送慢：配置量大，网络传输慢，万级别配置推送耗时 5 分钟</li>
<li>爆炸半径大：不支持配置拆分，错误配置影响解析流程，导致网关路由整体不可用</li>
<li>配置规模：单个 value 有 10M大小限制，仅支持千级别路由</li>
</ol>
<p>配置拆分势在必行，但其中困难也很多，例如动态监听的管理，稳定性的保障流程尤为复杂，额外提供的视图层与实际配置中心数据一致性保障等等。方案参考下图：</p>
<p><img src="https://image.cnkirito.cn/image-20230714164248026.png" alt="配置方案重构"></p>
<p>图中还有一个细节，也是我们优先选择 Nacos 作为配置中心的原因，nacos-client 的 snapshot 机制可以保证在管控以及配置中心组件都不可用时，即使网关 broker 重启了，依旧保证路由不丢失，保证自身可用性。</p>
<p>经过这套方案的改造，我们获得显著的优化效果：</p>
<ul>
<li><p>推送时间优化：1w 配置 5 分钟 -&gt; 30 秒</p>
</li>
<li><p>配置量上限提升：1000 -&gt; 10w</p>
</li>
<li><p>确保了配置推送的最终一致性</p>
</li>
</ul>
<h3 id="协议转换-x-服务发现"><a href="#协议转换-x-服务发现" class="headerlink" title="协议转换 x 服务发现"></a>协议转换 x 服务发现</h3><p>这两个企业级改造放到一起说，在实现上这两个模块也耦合的比较紧密。</p>
<p>协议转换：就以 Java 微服务体系而言，后端服务很有可能会出现 Dubbo 框架或者 GRPC 框架，甚至有些老的业务还会使用 WebService 这类框架，大多数时候我们说的网关都是只对接 HTTP 这一类通信协议，这限制了我们后端服务只能是 SpringBoot 或者 SpringCloud 框架，网关支持后端不同协议类型的能力，我们称之为协议转换。</p>
<p>服务发现：微服务框架离不开服务发现，一般常见的注册中心包括 Nacos、Eureka 等，例如开源 SpringCloud Gateway 便支持对接 Nacos/Eureka 两类注册中心。</p>
<p>这类开源特性的痛点是：</p>
<ol>
<li>SpringCloud Gateway 仅支持 HTTP2HTTP，不支持 HTTP2DUBBO，HTTP2GRPC，HTTP2WEBSERVICE</li>
<li>SpringCloud Gateway 仅支持单一注册中心的静态配置</li>
</ol>
<p>一些常见的企业级诉求：</p>
<ol>
<li>存在不同类型的微服务架构：SpringCloud、Dubbo、GRPC</li>
<li>网关支持跨环境访问，需要连接多个注册中心或者多个命名空间</li>
</ol>
<p>针对这些痛点和诉求，分享一些我们改造时遇到的难点以及经验</p>
<p><img src="https://image.cnkirito.cn/image-20230714171525533.png" alt="服务发现x协议转换扩展"></p>
<p>在支持不同协议时，对应的服务框架可能已经有了对应的 remoting 层和 discovery 层，我们的选择是仅引入该协议的 remoting 二方包解决协议转换问题，对于 discovery 层，应当自行封装，避免使用对应协议的 discovery 层这个误区，因为回归到网关领域，服务发现和协议转换是对等的模块，抽象 ServiceDiscoveryFIlter 负责服务发现，ProtocolTransferFilter 则负责点对点的协议通信。</p>
<p>在服务发现层，为了适配不同注册中心的模型（推和拉），提供了两个实现 PullServiceRegistry、PushServiceRegistry，这些改造是独立于 spring-cloud-loadbalancer 模块实现的，开源的默认实现存在诸多的限制，例如仅支持拉模型 + 缓存服务列表的方案，实际上推模型能够为网关的服务发现提供更高的实时性。</p>
<p>基本流程：服务发现 serviceName -&gt; n x IP，负载均衡 IP n -&gt;1，协议转换 IP 点对点通信</p>
<p>这样一套扩展机制可以在有新的协议类型、注册中心、负载均衡算法需要对接时实现快速扩展。</p>
<h3 id="限流熔断"><a href="#限流熔断" class="headerlink" title="限流熔断"></a>限流熔断</h3><p>如果仔细阅读过 SpringCloud Gateway 的文档，你会发现，开源对限流熔断的支持是非常有限的，它强依赖一个 Redis 做集群限流，且限流方案是自己实现的，而我们可能会更加信赖 Sentinel 提供的解决方案。事实上，开源 Sentinel 也对 SpringCloud Gateway 提供了一部分开箱即用的能力，使用层面完全没问题，主要是欠缺了一部分可观测性的能力。</p>
<p><img src="https://image.cnkirito.cn/image-20230714175044775.png" alt="限流熔断"></p>
<p>在改造中，尤为注意要使用高版本的 Sentinel，即按比例阈值这套模型实现的限流方案，集成 Sentinel 之后，我们按照网关的通用场景提供了两类限流模型：基于慢调用比例的限流熔断和基于响应码比例的限流熔断。借助于 Sentinel 的能力，可惜实现渐进式的恢复。</p>
<h3 id="可观测体系建设"><a href="#可观测体系建设" class="headerlink" title="可观测体系建设"></a>可观测体系建设</h3><p>可观测性体系的建设，可以说是很多开源产品距离企业级使用的距离，SpringCloud Gateway 亦是如此。</p>
<p><img src="https://image.cnkirito.cn/image-20230717135729732.png" alt="可观测性"></p>
<p>网关通常会需要记录三类可观测性指标。</p>
<ul>
<li>Metrics：如上图所示，记录请求数、QPS、响应码、P99、P999 等指标</li>
<li>Trace：网关链路能够串联后续微服务体系链路，实现全链路监控</li>
<li>Logging：按类别打印网关日志，常见的日志分类如 accessLog、requestLog、remotingLog 等</li>
</ul>
<p>开源 SpringCloud Gateway 集成了 micrometer-registry-prometheus，提供了一个开箱即用的大盘：<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-cloud-gateway/docs/3.1.8/reference/html/gateway-grafana-dashboard.json%EF%BC%8C%E9%9C%80%E8%A6%81%E6%9B%B4%E5%8A%A0%E4%B8%B0%E5%AF%8C%E7%BB%B4%E5%BA%A6%E7%9A%84%E6%8C%87%E6%A0%87%E5%88%99%E9%9C%80%E8%A6%81%E8%87%AA%E8%A1%8C%E5%9F%8B%E7%82%B9%E3%80%82">https://docs.spring.io/spring-cloud-gateway/docs/3.1.8/reference/html/gateway-grafana-dashboard.json，需要更加丰富维度的指标则需要自行埋点。</a></p>
<p>Trace 方案推荐对接 opentelemetry。</p>
<p>Logging 方案则是 SpringCloud Gateway 开源欠缺的，在实际生产中至少应该打印 accessLog 记录请求信息，按需开启 requestLog 记录请求的 payload 信息和响应体信息，以及与后端服务连接的日志，用于排查一些连接问题。日志采集方案我们的实践是将 accessLog 输出到标准输出中，方便在 K8s 架构下配置采集，或者采用日志 agent 的方案进行文件采集。</p>
<h2 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h2><p>除了功能层面的优化与新增，网关的性能也是使用者尤为关注的点。在前文中，我并没有把 SpringCloud Gateway 归为一个性能特别高的网关分类中，主要是基于我们的实践，发现其有不少优化空间。下面的章节我会分享一些基于 SpringCloud Gateway 进行的性能优化。</p>
<p>网关优化道阻且长，为了验证优化效果，建设性能基线不可避免，需要面向 benchmark 进行优化。</p>
<p>一些常用的优化技巧在网关中也同样适用，例如：缓存、懒加载、预分配、算法复杂度优化、CPU 友好操作，减少线程切换。</p>
<p><img src="https://image.cnkirito.cn/image-20230717144227071.png" alt="性能基线"></p>
<h3 id="火焰图"><a href="#火焰图" class="headerlink" title="火焰图"></a>火焰图</h3><p>通过火焰图观测性能可以从宏观角度分析大的性能损耗点</p>
<p><img src="https://image.cnkirito.cn/image-20230717144324186.png" alt="火焰图"></p>
<p>一个理想的网关火焰图应当是大部分的时间片占用花费在 IO 上，即图中的 netty 相关的损耗，除此之外占用了 CPU 的类，都需要重点关注。通过火焰图，我们也定位到了相当多的性能损耗点，并针对进行了优化。</p>
<h3 id="GlobalFilter-排序优化"><a href="#GlobalFilter-排序优化" class="headerlink" title="GlobalFilter 排序优化"></a>GlobalFilter 排序优化</h3><p>SpringCloud Gateway 中通过 GlobalFilter、GatewayFilter 对请求进行过滤，在 FilteringWebHandler 中可以看到这段逻辑</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Mono&lt;Void&gt; <span class="title">handle</span><span class="params">(ServerWebExchange exchange)</span> </span>&#123;</span><br><span class="line">	Route route = exchange.getRequiredAttribute(GATEWAY_ROUTE_ATTR);</span><br><span class="line">	List&lt;GatewayFilter&gt; gatewayFilters = route.getFilters();</span><br><span class="line"></span><br><span class="line">	List&lt;GatewayFilter&gt; combined = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="keyword">this</span>.globalFilters);</span><br><span class="line">	combined.addAll(gatewayFilters);</span><br><span class="line">	<span class="comment">// <span class="doctag">TODO:</span> needed or cached?</span></span><br><span class="line">	AnnotationAwareOrderComparator.sort(combined);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> DefaultGatewayFilterChain(combined).filter(exchange);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>开源实现在每次请求级别都会重新组装出一个 FilterChain，并进行排序，内存分配和排序会占用 CPU，无疑会导致性能下降，通过注释可以看到 Contributor 自己也意识到了这里的性能问题，但一直没有修复。</p>
<p>一个可行的优化手段是在路由或者策略变更时，触发 FilterChain 的更新，这样请求时 FilterChain 就没必要重新构造了。而观测到这一性能问题，正是通过了火焰图中的 FilteringWebHandler.handle 的占用。</p>
<h3 id="路由增量推送"><a href="#路由增量推送" class="headerlink" title="路由增量推送"></a>路由增量推送</h3><p>之前的企业级特性章节中，我介绍了配置中心改造的方案，其中提及了开源方案爆炸半径大的问题，可以从下面的代码中，窥见一斑：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RouteDefinitionRouteLocator</span> <span class="keyword">implements</span> <span class="title">RouteLocator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Flux&lt;Route&gt; <span class="title">getRoutes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		Flux&lt;Route&gt; routes = <span class="keyword">this</span>.routeDefinitionLocator.getRouteDefinitions().map(<span class="keyword">this</span>::convertToRoute);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (!gatewayProperties.isFailOnRouteDefinitionError()) &#123;</span><br><span class="line">			<span class="comment">// instead of letting error bubble up, continue</span></span><br><span class="line">			routes = routes.onErrorContinue((error, obj) -&gt; &#123;</span><br><span class="line">				<span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">					logger.warn(<span class="string">&quot;RouteDefinition id &quot;</span> + ((RouteDefinition) obj).getId()</span><br><span class="line">							+ <span class="string">&quot; will be ignored. Definition has invalid configs, &quot;</span> + error.getMessage());</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> routes.map(route -&gt; &#123;</span><br><span class="line">			<span class="keyword">return</span> route;</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>可以见得，SpringCloud Gateway 认为路由配置是一个整体，任意路由的变更，就会导致整个 Route 序列重新构建。并且在默认情况下，如果其中一个路由配置出错了，会导致整个网关路由不可用，除非 isFailOnRouteDefinitionError 被关闭。</p>
<p>我们的改造方案是使用 Map 结构进行改造，配合路由配置的增量推送，实现 Route 的单点更新。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicRouteRepository</span> <span class="keyword">implements</span> <span class="title">Ordered</span>, <span class="title">RouteLocator</span>, <span class="title">ApplicationEventPublisherAware</span>, <span class="title">RouteDefinitionWriter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> RouteConverter routeConverter;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">RouteKey</span> <span class="keyword">implements</span> <span class="title">Ordered</span> </span>&#123;</span><br><span class="line">		<span class="keyword">private</span> String id;</span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">int</span> order;</span><br><span class="line">    ...</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">final</span> Map&lt;RouteKey, Route&gt; ORDERED_ROUTE = <span class="keyword">new</span> TreeMap&lt;&gt;((o1, o2) -&gt; &#123;</span><br><span class="line">		<span class="keyword">int</span> order1 = o1.order;</span><br><span class="line">		<span class="keyword">int</span> order2 = o2.order;</span><br><span class="line">		<span class="keyword">if</span> (order1 != order2) &#123;</span><br><span class="line">			<span class="keyword">return</span> Integer.compare(order1, order2);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> o1.id.compareTo(o2.id);</span><br><span class="line">	&#125;);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;String, Integer&gt; ORDER = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Route <span class="title">getRouteById</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> ORDERED_ROUTE.get(<span class="keyword">new</span> RouteKey(id, ORDER.getOrDefault(id, <span class="number">0</span>)));</span><br><span class="line">	&#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="路由内存优化"><a href="#路由内存优化" class="headerlink" title="路由内存优化"></a>路由内存优化</h3><p>这个优化来自于我们一次生产问题的排查，起初我们并没有意识到该问题。问题表现为路由数量非常大时，内存占用的消耗超过了我们的预期，经过 dump 发现，同一份路由的配置内容竟然以 3 种形式常驻于内存中</p>
<ul>
<li>Nacos 配置中心自身的 Cache</li>
<li>SpringCloud Gateway 路由定义 RouteDefinition 的占用</li>
<li>SpringCloud Gateway 真实路由 Route 的占用</li>
</ul>
<p>Nacos 的占用在我们预期之类，但 RouteDefinition 其实仅仅是一个中间变量，如果流程合理，其实是没必要常驻内存的，经过优化，我们去除了一份占用，增加了支持路由的数量。</p>
<h3 id="内存泄漏优化"><a href="#内存泄漏优化" class="headerlink" title="内存泄漏优化"></a>内存泄漏优化</h3><p>该问题通用来自于生产实践，SpringCloud Gateway 底层依赖 netty 进行 IO 通信，熟悉 netty 的人应当知道其有一个读写缓冲的设计，如果通信内容较小，一般会命中 chunked buffer，而通信内容较大时，例如文件上传，则会触发内存的新分配，而 SpringCloud Gateway 在对接 netty 时存在逻辑缺陷，会导致新分配的池化内存无法完全回收，导致堆外内存泄漏。并且这块堆外内存时 netty 使用 unsafe 自行分配的，通过常规的 JVM 工具还无法观测，非常隐蔽。</p>
<p>处于改造成本考量，我们最终选择的方案是增加一行启动参数 <code>-Dio.netty.allocator.type=unpooled</code>，使得请求未命中 chunked buffer 时，分配的临时内存不进行池化，规避内存性能问题。</p>
<p>可能有人会有疑问，<code>-Dio.netty.allocator.type=unpooled</code>会不会导致性能下降，这个担心完毕没有必要，首先只有大报文才会触发该内存的分配，而网关的最佳实践应该是不允许文件上传这类需求，加上该参数只是为了应对非主流场景的一个兜底行为。</p>
<h3 id="预构建-URI"><a href="#预构建-URI" class="headerlink" title="预构建 URI"></a>预构建 URI</h3><p>该热点问题由 <code>org.springframework.cloud.client.loadbalancer.LoadBalancerUriTools</code> 贡献，SpringCloud Gateway 引用了 spring-cloud-loadbalancer 解决服务发现和负载均衡的问题，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> URI <span class="title">doReconstructURI</span><span class="params">(ServiceInstance serviceInstance, URI original)</span> </span>&#123;</span><br><span class="line">    String host = serviceInstance.getHost();</span><br><span class="line">    String scheme = (String)Optional.ofNullable(serviceInstance.getScheme()).orElse(computeScheme(original, serviceInstance));</span><br><span class="line">    <span class="keyword">int</span> port = computePort(serviceInstance.getPort(), scheme);</span><br><span class="line">    <span class="keyword">if</span> (Objects.equals(host, original.getHost()) &amp;&amp; port == original.getPort() &amp;&amp; Objects.equals(scheme, original.getScheme())) &#123;</span><br><span class="line">        <span class="keyword">return</span> original;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> encoded = containsEncodedParts(original);</span><br><span class="line">        <span class="keyword">return</span> UriComponentsBuilder.fromUri(original).scheme(scheme).host(host).port(port).build(encoded).toUri();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意最后一行构建，实际是针对不可变对象的一次变更，从而进行了一次深拷贝，重新重构了一个 URI，这样的行为同样发生在调用级别，不要小看这类行为，它会严重占用 CPU。</p>
<p>优化方案便是，对于不可变部分的构造，提前到路由推送时构建，对于可变的调用级别的参数，支持修改。这一点跟路由增量推送的优化是一个道理。</p>
<p>Spring 体系出于契约考虑，大量使用了不可变变量传递契约信息，但某些扩展点中，又的确希望对其进行变更，不得已进行了深拷贝，从而造成了性能下降，企业级应用需要在其中寻找到一个平衡点。</p>
<h3 id="对象缓存"><a href="#对象缓存" class="headerlink" title="对象缓存"></a>对象缓存</h3><p>尽量避免调用链路中出现 new 关键字，它会加大 CPU 的开销，从而影响 IO，可以使用 ThreadLocal 或者对象池化技术进行对象复用。</p>
<p>如果 new 关键词仅出现在初始化，配置推送等异步场景，通常是一次性的行为，则出于代码可读性的考虑，不做太多要求。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>今天的分享简单介绍了一些主流的网关的对比，并重点介绍了 SpringCloud Gateway 适用的场景。并分析了 SpringCloud Gateway 如果在企业中投入生产使用，我们认为需要新增&amp;改造的一些能力，最后针对一些常见的性能优化场景，介绍了我们的一些优化方案。这些经验完全来源我们 CSB 2.0 微服务网关基于 SpringCloud Gateway 改造的实践，CSB 2.0 是一款适用于私有化输出的网关产品，在今年，我们也会在公有云 EDAS 中将其进行输出，敬请期待。</p>
</div><div class="article-licensing box"><div class="licensing-title"><p>SpringCloud Gateway 在微服务架构下的最佳实践</p><p><a href="https://www.cnkirito.moe/scg-microservice-practise/">https://www.cnkirito.moe/scg-microservice-practise/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>徐靖峰</p></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2023-07-07</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2025-12-22</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icon" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a><a class="icon" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a><a class="icon" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><hr style="height:1px;margin:1rem 0"><div class="level is-mobile is-flex"><div class="article-tags is-size-7 is-uppercase"><i class="fas fa-tags has-text-grey"></i> <a class="link-muted" rel="tag" href="/tags/Spring-Cloud-Gateway/">Spring Cloud Gateway </a></div></div><!--!--></article></div><div class="card"><div class="card-content"><h3 class="menu-label has-text-centered">喜欢这篇文章？打赏一下作者吧</h3><div class="buttons is-centered"><a class="button donate" data-type="alipay"><span class="icon is-small"><i class="fab fa-alipay"></i></span><span>支付宝</span><span class="qrcode"><img src="/img/alipay.png" alt="支付宝"></span></a><a class="button donate" data-type="wechat"><span class="icon is-small"><i class="fab fa-weixin"></i></span><span>微信</span><span class="qrcode"><img src="/img/wechatpay.png" alt="微信"></span></a></div></div></div><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/edas-scg-agent/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">EDAS 让 Spring Cloud Gateway 生产可用的二三策</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/house-customization/"><span class="level-item">Kirito 全屋定制记 | 纯小白向全屋定制攻略</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><!--!--></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/avatar.png" alt="徐靖峰"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">徐靖峰</p><p class="is-size-6 is-block">阿里巴巴中间件研发</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>中国·杭州</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">180</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">14</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">77</p></a></div></div></nav><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/wechat_public.jpg" alt="Kirito的技术分享"></figure><div class="level"><a class="level-item button is-primary is-rounded" target="_blank" rel="noopener">↑关注微信公众号↑</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/lexburner"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="WeChat" href="/img/wechat_public.jpg"><i class="fab fa-weixin"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="RSS" href="/atom.xml"><i class="fas fa-rss"></i></a></div></div></div><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="level is-mobile" href="#前言"><span class="level-left"><span class="level-item">1</span><span class="level-item">前言</span></span></a></li><li><a class="level is-mobile" href="#为什么需要微服务网关"><span class="level-left"><span class="level-item">2</span><span class="level-item">为什么需要微服务网关</span></span></a></li><li><a class="level is-mobile" href="#微服务网关核心功能"><span class="level-left"><span class="level-item">3</span><span class="level-item">微服务网关核心功能</span></span></a></li><li><a class="level is-mobile" href="#网关选型对比"><span class="level-left"><span class="level-item">4</span><span class="level-item">网关选型对比</span></span></a></li><li><a class="level is-mobile" href="#SpringCloud-Gateway-介绍"><span class="level-left"><span class="level-item">5</span><span class="level-item">SpringCloud Gateway 介绍</span></span></a></li><li><a class="level is-mobile" href="#开源特性-vs-企业级特性需求"><span class="level-left"><span class="level-item">6</span><span class="level-item">开源特性 vs 企业级特性需求</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#白屏化管控"><span class="level-left"><span class="level-item">6.1</span><span class="level-item">白屏化管控</span></span></a></li><li><a class="level is-mobile" href="#配置方案重构"><span class="level-left"><span class="level-item">6.2</span><span class="level-item">配置方案重构</span></span></a></li><li><a class="level is-mobile" href="#协议转换-x-服务发现"><span class="level-left"><span class="level-item">6.3</span><span class="level-item">协议转换 x 服务发现</span></span></a></li><li><a class="level is-mobile" href="#限流熔断"><span class="level-left"><span class="level-item">6.4</span><span class="level-item">限流熔断</span></span></a></li><li><a class="level is-mobile" href="#可观测体系建设"><span class="level-left"><span class="level-item">6.5</span><span class="level-item">可观测体系建设</span></span></a></li></ul></li><li><a class="level is-mobile" href="#性能优化"><span class="level-left"><span class="level-item">7</span><span class="level-item">性能优化</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#火焰图"><span class="level-left"><span class="level-item">7.1</span><span class="level-item">火焰图</span></span></a></li><li><a class="level is-mobile" href="#GlobalFilter-排序优化"><span class="level-left"><span class="level-item">7.2</span><span class="level-item">GlobalFilter 排序优化</span></span></a></li><li><a class="level is-mobile" href="#路由增量推送"><span class="level-left"><span class="level-item">7.3</span><span class="level-item">路由增量推送</span></span></a></li><li><a class="level is-mobile" href="#路由内存优化"><span class="level-left"><span class="level-item">7.4</span><span class="level-item">路由内存优化</span></span></a></li><li><a class="level is-mobile" href="#内存泄漏优化"><span class="level-left"><span class="level-item">7.5</span><span class="level-item">内存泄漏优化</span></span></a></li><li><a class="level is-mobile" href="#预构建-URI"><span class="level-left"><span class="level-item">7.6</span><span class="level-item">预构建 URI</span></span></a></li><li><a class="level is-mobile" href="#对象缓存"><span class="level-left"><span class="level-item">7.7</span><span class="level-item">对象缓存</span></span></a></li></ul></li><li><a class="level is-mobile" href="#总结"><span class="level-left"><span class="level-item">8</span><span class="level-item">总结</span></span></a></li></ul></div></div><script src="/js/toc.js" defer></script></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/avatar.png" alt="徐靖峰|个人博客" height="28"></a><p class="is-size-7"><span>&copy; 2026 徐靖峰</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><div id="outdated"><h6>Your browser is out-of-date!</h6><p>Update your browser to view this website correctly.&amp;npsb;<a id="btnUpdateBrowser" target="_blank" rel="noopener" href="http://outdatedbrowser.com/">Update my browser now </a></p><p class="last"><a href="#" id="btnCloseUpdateBrowser" title="Close">×</a></p></div><script src="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.js" defer></script><script>window.addEventListener("load", function () {
            outdatedBrowser({
                bgColor: '#f25648',
                color: '#ffffff',
                lowerThan: 'object-fit' // display on IE11 or below
            });
        });</script><!--!--><!--!--><!--!--><script src="/js/scroll-animations.js" defer></script><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>