<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>Spring Security(四)-- 核心过滤器源码分析 - 徐靖峰|个人博客</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="Kirito的技术分享"><meta name="msapplication-TileImage" content="/img/avatar.png"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Kirito的技术分享"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="前面的部分，我们关注了 Spring Security 是如何完成认证工作的，但是另外一部分核心的内容：过滤器，一直没有提到，我们已经知道 Spring Security 使用了 springSecurityFillterChian 作为了安全过滤的入口，这一节主要分析一下这个过滤器链都包含了哪些关键的过滤器，并且各自的使命是什么。 4 过滤器详解4.1 核心过滤器概述由于过滤器链路中的过滤较多，"><meta property="og:type" content="blog"><meta property="og:title" content="Spring Security(四)-- 核心过滤器源码分析"><meta property="og:url" content="https://www.cnkirito.moe/spring-security-4/"><meta property="og:site_name" content="徐靖峰|个人博客"><meta property="og:description" content="前面的部分，我们关注了 Spring Security 是如何完成认证工作的，但是另外一部分核心的内容：过滤器，一直没有提到，我们已经知道 Spring Security 使用了 springSecurityFillterChian 作为了安全过滤的入口，这一节主要分析一下这个过滤器链都包含了哪些关键的过滤器，并且各自的使命是什么。 4 过滤器详解4.1 核心过滤器概述由于过滤器链路中的过滤较多，"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://image.cnkirito.cn/2011121410543010.jpg"><meta property="og:image" content="https://image.cnkirito.cn/QQ%E5%9B%BE%E7%89%8720170929231608.png"><meta property="og:image" content="https://image.cnkirito.cn/qrcode_for_gh_c06057be7960_258%20%281%29.jpg"><meta property="article:published_time" content="2017-09-30T23:25:34.000Z"><meta property="article:modified_time" content="2025-07-01T03:18:09.739Z"><meta property="article:author" content="徐靖峰"><meta property="article:tag" content="Spring Security"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="https://image.cnkirito.cn/2011121410543010.jpg"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://www.cnkirito.moe/spring-security-4/"},"headline":"Spring Security(四)-- 核心过滤器源码分析","image":["https://image.cnkirito.cn/2011121410543010.jpg","https://image.cnkirito.cn/QQ%E5%9B%BE%E7%89%8720170929231608.png","https://image.cnkirito.cn/qrcode_for_gh_c06057be7960_258%20%281%29.jpg"],"datePublished":"2017-09-30T23:25:34.000Z","dateModified":"2025-07-01T03:18:09.739Z","author":{"@type":"Person","name":"徐靖峰"},"description":"前面的部分，我们关注了 Spring Security 是如何完成认证工作的，但是另外一部分核心的内容：过滤器，一直没有提到，我们已经知道 Spring Security 使用了 springSecurityFillterChian 作为了安全过滤的入口，这一节主要分析一下这个过滤器链都包含了哪些关键的过滤器，并且各自的使命是什么。 4 过滤器详解4.1 核心过滤器概述由于过滤器链路中的过滤较多，"}</script><link rel="canonical" href="https://www.cnkirito.moe/spring-security-4/"><link rel="icon" href="/img/avatar.png"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.12.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><script src="https://www.googletagmanager.com/gtag/js?id=UA-118574570-1" async></script><script>window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
    
        gtag('config', 'UA-118574570-1');</script><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.css"><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><!--!--><!--!--><meta name="generator" content="Hexo 5.4.0"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/avatar.png" alt="徐靖峰|个人博客" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/.">主页</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/archives">归档</a><a class="navbar-item" href="/about">关于</a><a class="navbar-item" target="_blank" rel="noopener" href="https://github.com/YunaiV/onemall">开源项目</a></div><div class="navbar-end"><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-9-widescreen"><div class="card"><article class="card-content article" id="article-content" role="article"><h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal"><i class="fas fa-angle-double-right"></i>Spring Security(四)-- 核心过滤器源码分析</h1><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><i class="far fa-calendar-alt"> </i><time dateTime="${date_xml(page.date)}" title="${date_xml(page.date)}">2017-09-30</time></span><span class="level-item is-hidden-mobile"><i class="far fa-calendar-check"> </i><time dateTime="${date_xml(page.updated)}" title="${date_xml(page.updated)}">2025-07-01</time></span><span class="level-item"><a class="link-muted" href="/categories/Spring-Security/">Spring Security</a></span><span class="level-item">30 分钟读完 (大约4546个字)</span></div></div><div class="content"><p>前面的部分，我们关注了 Spring Security 是如何完成认证工作的，但是另外一部分核心的内容：过滤器，一直没有提到，我们已经知道 Spring Security 使用了 springSecurityFillterChian 作为了安全过滤的入口，这一节主要分析一下这个过滤器链都包含了哪些关键的过滤器，并且各自的使命是什么。</p>
<h2 id="4-过滤器详解"><a href="#4-过滤器详解" class="headerlink" title="4 过滤器详解"></a>4 过滤器详解</h2><h3 id="4-1-核心过滤器概述"><a href="#4-1-核心过滤器概述" class="headerlink" title="4.1 核心过滤器概述"></a>4.1 核心过滤器概述</h3><p>由于过滤器链路中的过滤较多，即使是 Spring Security 的官方文档中也并未对所有的过滤器进行介绍，在之前，《Spring Security(二)–Guides》入门指南中我们配置了一个表单登录的 demo，以此为例，来看看这过程中 Spring Security 都帮我们自动配置了哪些过滤器。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Creating filter chain: o.s.s.web.util.matcher.AnyRequestMatcher@<span class="number">1</span>, </span><br><span class="line">[o.s.s.web.context.SecurityContextPersistenceFilter@8851ce1, </span><br><span class="line">o.s.s.web.header.HeaderWriterFilter@6a472566, o.s.s.web.csrf.CsrfFilter@61cd1c71, </span><br><span class="line">o.s.s.web.authentication.logout.LogoutFilter@5e1d03d7, </span><br><span class="line">o.s.s.web.authentication.UsernamePasswordAuthenticationFilter@122d6c22, </span><br><span class="line">o.s.s.web.savedrequest.RequestCacheAwareFilter@5ef6fd7f, </span><br><span class="line">o.s.s.web.servletapi.SecurityContextHolderAwareRequestFilter@4beaf6bd, </span><br><span class="line">o.s.s.web.authentication.AnonymousAuthenticationFilter@6edcad64, </span><br><span class="line">o.s.s.web.session.SessionManagementFilter@5e65afb6, </span><br><span class="line">o.s.s.web.access.ExceptionTranslationFilter@5b9396d3, </span><br><span class="line">o.s.s.web.access.intercept.FilterSecurityInterceptor@3c5dbdf8</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>上述的 log 信息是我从 springboot 启动的日志中 CV 所得，spring security 的过滤器日志有一个特点：log 打印顺序与实际配置顺序符合，也就意味着 <code>SecurityContextPersistenceFilter</code> 是整个过滤器链的第一个过滤器，而 <code>FilterSecurityInterceptor</code> 则是末置的过滤器。另外通过观察过滤器的名称，和所在的包名，可以大致地分析出他们各自的作用，如 <code>UsernamePasswordAuthenticationFilter</code> 明显便是与使用用户名和密码登录相关的过滤器，而 <code>FilterSecurityInterceptor</code> 我们似乎看不出它的作用，但是其位于 <code>web.access</code> 包下，大致可以分析出他与访问限制相关。第四篇文章主要就是介绍这些常用的过滤器，对其中关键的过滤器进行一些源码分析。先大致介绍下每个过滤器的作用：</p>
<ul>
<li><strong>SecurityContextPersistenceFilter</strong> 两个主要职责：请求来临时，创建 <code>SecurityContext</code> 安全上下文信息，请求结束时清空 <code>SecurityContextHolder</code>。</li>
<li>HeaderWriterFilter (文档中并未介绍，非核心过滤器) 用来给 http 响应添加一些 Header, 比如 X-Frame-Options, X-XSS-Protection*，X-Content-Type-Options.</li>
<li>CsrfFilter 在 spring4 这个版本中被默认开启的一个过滤器，用于防止 csrf 攻击，了解前后端分离的人一定不会对这个攻击方式感到陌生，前后端使用 json 交互需要注意的一个问题。</li>
<li>LogoutFilter 顾名思义，处理注销的过滤器</li>
<li><strong>UsernamePasswordAuthenticationFilter</strong> 这个会重点分析，表单提交了 username 和 password，被封装成 token 进行一系列的认证，便是主要通过这个过滤器完成的，在表单认证的方法中，这是最最关键的过滤器。</li>
<li>RequestCacheAwareFilter  (文档中并未介绍，非核心过滤器) 内部维护了一个 RequestCache，用于缓存 request 请求</li>
<li>SecurityContextHolderAwareRequestFilter 此过滤器对 ServletRequest 进行了一次包装，使得 request 具有更加丰富的 API</li>
<li><strong>AnonymousAuthenticationFilter</strong> 匿名身份过滤器，这个过滤器个人认为很重要，需要将它与 UsernamePasswordAuthenticationFilter 放在一起比较理解，spring security 为了兼容未登录的访问，也走了一套认证流程，只不过是一个匿名的身份。</li>
<li>SessionManagementFilter 和 session 相关的过滤器，内部维护了一个 SessionAuthenticationStrategy，两者组合使用，常用来防止 <code>session-fixation protection attack</code>，以及限制同一用户开启多个会话的数量</li>
<li><strong>ExceptionTranslationFilter</strong> 直译成异常翻译过滤器，还是比较形象的，这个过滤器本身不处理异常，而是将认证过程中出现的异常交给内部维护的一些类去处理，具体是那些类下面详细介绍</li>
<li><strong>FilterSecurityInterceptor</strong> 这个过滤器决定了访问特定路径应该具备的权限，访问的用户的角色，权限是什么？访问的路径需要什么样的角色和权限？这些判断和处理都是由该类进行的。</li>
</ul>
<p>其中加粗的过滤器可以被认为是 Spring Security 的核心过滤器，将在下面，一个过滤器对应一个小节来讲解。</p>
<h3 id="4-2-SecurityContextPersistenceFilter"><a href="#4-2-SecurityContextPersistenceFilter" class="headerlink" title="4.2 SecurityContextPersistenceFilter"></a>4.2 SecurityContextPersistenceFilter</h3><p>试想一下，如果我们不使用 Spring Security，如果保存用户信息呢，大多数情况下会考虑使用 Session 对吧？在 Spring Security 中也是如此，用户在登录过一次之后，后续的访问便是通过 sessionId 来识别，从而认为用户已经被认证。具体在何处存放用户信息，便是第一篇文章中提到的 SecurityContextHolder；认证相关的信息是如何被存放到其中的，便是通过 SecurityContextPersistenceFilter。在 4.1 概述中也提到了，SecurityContextPersistenceFilter 的两个主要作用便是请求来临时，创建 <code>SecurityContext</code> 安全上下文信息和请求结束时清空 <code>SecurityContextHolder</code>。顺带提一下：微服务的一个设计理念需要实现服务通信的无状态，而 http 协议中的无状态意味着不允许存在 session，这可以通过 <code>setAllowSessionCreation(false)</code> 实现，这并不意味着 SecurityContextPersistenceFilter 变得无用，因为它还需要负责清除用户信息。在 Spring Security 中，虽然安全上下文信息被存储于 Session 中，但我们在实际使用中不应该直接操作 Session，而应当使用 SecurityContextHolder。</p>
<h4 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h4><p><code>org.springframework.security.web.context.SecurityContextPersistenceFilter</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecurityContextPersistenceFilter</span> <span class="keyword">extends</span> <span class="title">GenericFilterBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> String FILTER_APPLIED = <span class="string">&quot;__spring_security_scpf_applied&quot;</span>;</span><br><span class="line">   <span class="comment">// 安全上下文存储的仓库</span></span><br><span class="line">   <span class="keyword">private</span> SecurityContextRepository repo;</span><br><span class="line">  </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">SecurityContextPersistenceFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">//HttpSessionSecurityContextRepository 是 SecurityContextRepository 接口的一个实现类</span></span><br><span class="line">      <span class="comment">// 使用 HttpSession 来存储 SecurityContext</span></span><br><span class="line">      <span class="keyword">this</span>(<span class="keyword">new</span> HttpSessionSecurityContextRepository());</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest req, ServletResponse res, FilterChain chain)</span></span></span><br><span class="line"><span class="function">         <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">      HttpServletRequest request = (HttpServletRequest) req;</span><br><span class="line">      HttpServletResponse response = (HttpServletResponse) res;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (request.getAttribute(FILTER_APPLIED) != <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="comment">// ensure that filter is only applied once per request</span></span><br><span class="line">         chain.doFilter(request, response);</span><br><span class="line">         <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      request.setAttribute(FILTER_APPLIED, Boolean.TRUE);</span><br><span class="line">      <span class="comment">// 包装 request，response</span></span><br><span class="line">      HttpRequestResponseHolder holder = <span class="keyword">new</span> HttpRequestResponseHolder(request,</span><br><span class="line">            response);</span><br><span class="line">      <span class="comment">// 从 Session 中获取安全上下文信息</span></span><br><span class="line">      SecurityContext contextBeforeChainExecution = repo.loadContext(holder);</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="comment">// 请求开始时，设置安全上下文信息，这样就避免了用户直接从 Session 中获取安全上下文信息</span></span><br><span class="line">         SecurityContextHolder.setContext(contextBeforeChainExecution);</span><br><span class="line">         chain.doFilter(holder.getRequest(), holder.getResponse());</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">finally</span> &#123;</span><br><span class="line">         <span class="comment">// 请求结束后，清空安全上下文信息</span></span><br><span class="line">         SecurityContext contextAfterChainExecution = SecurityContextHolder</span><br><span class="line">               .getContext();</span><br><span class="line">         SecurityContextHolder.clearContext();</span><br><span class="line">         repo.saveContext(contextAfterChainExecution, holder.getRequest(),</span><br><span class="line">               holder.getResponse());</span><br><span class="line">         request.removeAttribute(FILTER_APPLIED);</span><br><span class="line">         <span class="keyword">if</span> (debug) &#123;</span><br><span class="line">            logger.debug(<span class="string">&quot;SecurityContextHolder now cleared, as request processing completed&quot;</span>);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>过滤器一般负责核心的处理流程，而具体的业务实现，通常交给其中聚合的其他实体类，这在 Filter 的设计中很常见，同时也符合职责分离模式。例如存储安全上下文和读取安全上下文的工作完全委托给了 HttpSessionSecurityContextRepository 去处理，而这个类中也有几个方法可以稍微解读下，方便我们理解内部的工作流程</p>
<p><code>org.springframework.security.web.context.HttpSessionSecurityContextRepository</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpSessionSecurityContextRepository</span> <span class="keyword">implements</span> <span class="title">SecurityContextRepository</span> </span>&#123;</span><br><span class="line">   <span class="comment">// &#x27;SPRING_SECURITY_CONTEXT&#x27; 是安全上下文默认存储在 Session 中的键值</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String SPRING_SECURITY_CONTEXT_KEY = <span class="string">&quot;SPRING_SECURITY_CONTEXT&quot;</span>;</span><br><span class="line">   ...</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> Object contextObject = SecurityContextHolder.createEmptyContext();</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">boolean</span> allowSessionCreation = <span class="keyword">true</span>;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">boolean</span> disableUrlRewriting = <span class="keyword">false</span>;</span><br><span class="line">   <span class="keyword">private</span> String springSecurityContextKey = SPRING_SECURITY_CONTEXT_KEY;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> AuthenticationTrustResolver trustResolver = <span class="keyword">new</span> AuthenticationTrustResolverImpl();</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 从当前 request 中取出安全上下文，如果 session 为空，则会返回一个新的安全上下文</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> SecurityContext <span class="title">loadContext</span><span class="params">(HttpRequestResponseHolder requestResponseHolder)</span> </span>&#123;</span><br><span class="line">      HttpServletRequest request = requestResponseHolder.getRequest();</span><br><span class="line">      HttpServletResponse response = requestResponseHolder.getResponse();</span><br><span class="line">      HttpSession httpSession = request.getSession(<span class="keyword">false</span>);</span><br><span class="line">      SecurityContext context = readSecurityContextFromSession(httpSession);</span><br><span class="line">      <span class="keyword">if</span> (context == <span class="keyword">null</span>) &#123;</span><br><span class="line">         context = generateNewContext();</span><br><span class="line">      &#125;</span><br><span class="line">      ...</span><br><span class="line">      <span class="keyword">return</span> context;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   ...</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsContext</span><span class="params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">      HttpSession session = request.getSession(<span class="keyword">false</span>);</span><br><span class="line">      <span class="keyword">if</span> (session == <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> session.getAttribute(springSecurityContextKey) != <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> SecurityContext <span class="title">readSecurityContextFromSession</span><span class="params">(HttpSession httpSession)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (httpSession == <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      ...</span><br><span class="line">      <span class="comment">// Session 存在的情况下，尝试获取其中的 SecurityContext</span></span><br><span class="line">      Object contextFromSession = httpSession.getAttribute(springSecurityContextKey);</span><br><span class="line">      <span class="keyword">if</span> (contextFromSession == <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      ...</span><br><span class="line">      <span class="keyword">return</span> (SecurityContext) contextFromSession;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 初次请求时创建一个新的 SecurityContext 实例</span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> SecurityContext <span class="title">generateNewContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> SecurityContextHolder.createEmptyContext();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SecurityContextPersistenceFilter 和 HttpSessionSecurityContextRepository 配合使用，构成了 Spring Security 整个调用链路的入口，为什么将它放在最开始的地方也是显而易见的，后续的过滤器中大概率会依赖 Session 信息和安全上下文信息。</p>
<h3 id="4-3-UsernamePasswordAuthenticationFilter"><a href="#4-3-UsernamePasswordAuthenticationFilter" class="headerlink" title="4.3 UsernamePasswordAuthenticationFilter"></a>4.3 UsernamePasswordAuthenticationFilter</h3><p>表单认证是最常用的一个认证方式，一个最直观的业务场景便是允许用户在表单中输入用户名和密码进行登录，而这背后的 UsernamePasswordAuthenticationFilter，在整个 Spring Security 的认证体系中则扮演着至关重要的角色。</p>
<p><img src="https://image.cnkirito.cn/2011121410543010.jpg" alt="https://image.cnkirito.cn/2011121410543010.jpg"></p>
<p>上述的时序图，可以看出 UsernamePasswordAuthenticationFilter 主要肩负起了调用身份认证器，校验身份的作用，至于认证的细节，在前面几章花了很大篇幅进行了介绍，到这里，其实 Spring Security 的基本流程就已经走通了。</p>
<h4 id="源码分析-1"><a href="#源码分析-1" class="headerlink" title="源码分析"></a>源码分析</h4><p><code>org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter#attemptAuthentication</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Authentication <span class="title">attemptAuthentication</span><span class="params">(HttpServletRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">      HttpServletResponse response)</span> <span class="keyword">throws</span> AuthenticationException </span>&#123;</span><br><span class="line">   <span class="comment">// 获取表单中的用户名和密码</span></span><br><span class="line">   String username = obtainUsername(request);</span><br><span class="line">   String password = obtainPassword(request);</span><br><span class="line">   ...</span><br><span class="line">   username = username.trim();</span><br><span class="line">   <span class="comment">// 组装成 username+password 形式的 token</span></span><br><span class="line">   UsernamePasswordAuthenticationToken authRequest = <span class="keyword">new</span> UsernamePasswordAuthenticationToken(</span><br><span class="line">         username, password);</span><br><span class="line">   <span class="comment">// Allow subclasses to set the &quot;details&quot; property</span></span><br><span class="line">   setDetails(request, authRequest);</span><br><span class="line">   <span class="comment">// 交给内部的 AuthenticationManager 去认证，并返回认证信息</span></span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">this</span>.getAuthenticationManager().authenticate(authRequest);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>UsernamePasswordAuthenticationFilter</code> 本身的代码只包含了上述这么一个方法，非常简略，而在其父类 <code>AbstractAuthenticationProcessingFilter</code> 中包含了大量的细节，值得我们分析：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractAuthenticationProcessingFilter</span> <span class="keyword">extends</span> <span class="title">GenericFilterBean</span></span></span><br><span class="line"><span class="class">      <span class="keyword">implements</span> <span class="title">ApplicationEventPublisherAware</span>, <span class="title">MessageSourceAware</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 包含了一个身份认证器</span></span><br><span class="line">	<span class="keyword">private</span> AuthenticationManager authenticationManager;</span><br><span class="line">	<span class="comment">// 用于实现 remeberMe</span></span><br><span class="line">	<span class="keyword">private</span> RememberMeServices rememberMeServices = <span class="keyword">new</span> NullRememberMeServices();</span><br><span class="line">	<span class="keyword">private</span> RequestMatcher requiresAuthenticationRequestMatcher;</span><br><span class="line">	<span class="comment">// 这两个 Handler 很关键，分别代表了认证成功和失败相应的处理器</span></span><br><span class="line">	<span class="keyword">private</span> AuthenticationSuccessHandler successHandler = <span class="keyword">new</span> SavedRequestAwareAuthenticationSuccessHandler();</span><br><span class="line">	<span class="keyword">private</span> AuthenticationFailureHandler failureHandler = <span class="keyword">new</span> SimpleUrlAuthenticationFailureHandler();</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest req, ServletResponse res, FilterChain chain)</span></span></span><br><span class="line"><span class="function">			<span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line"></span><br><span class="line">		HttpServletRequest request = (HttpServletRequest) req;</span><br><span class="line">		HttpServletResponse response = (HttpServletResponse) res;</span><br><span class="line">		...</span><br><span class="line">		Authentication authResult;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">// 此处实际上就是调用 UsernamePasswordAuthenticationFilter 的 attemptAuthentication 方法</span></span><br><span class="line">			authResult = attemptAuthentication(request, response);</span><br><span class="line">			<span class="keyword">if</span> (authResult == <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="comment">// 子类未完成认证，立刻返回</span></span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			sessionStrategy.onAuthentication(authResult, request, response);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 在认证过程中可以直接抛出异常，在过滤器中，就像此处一样，进行捕获</span></span><br><span class="line">		<span class="keyword">catch</span> (InternalAuthenticationServiceException failed) &#123;</span><br><span class="line">			<span class="comment">// 内部服务异常</span></span><br><span class="line">			unsuccessfulAuthentication(request, response, failed);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (AuthenticationException failed) &#123;</span><br><span class="line">			<span class="comment">// 认证失败</span></span><br><span class="line">			unsuccessfulAuthentication(request, response, failed);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 认证成功</span></span><br><span class="line">		<span class="keyword">if</span> (continueChainBeforeSuccessfulAuthentication) &#123;</span><br><span class="line">			chain.doFilter(request, response);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 注意，认证成功后过滤器把 authResult 结果也传递给了成功处理器</span></span><br><span class="line">		successfulAuthentication(request, response, chain, authResult);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>整个流程理解起来也并不难，主要就是内部调用了 authenticationManager 完成认证，根据认证结果执行 successfulAuthentication 或者 unsuccessfulAuthentication，无论成功失败，一般的实现都是转发或者重定向等处理，不再细究 AuthenticationSuccessHandler 和 AuthenticationFailureHandler，有兴趣的朋友，可以去看看两者的实现类。</p>
<h3 id="4-4-AnonymousAuthenticationFilter"><a href="#4-4-AnonymousAuthenticationFilter" class="headerlink" title="4.4 AnonymousAuthenticationFilter"></a>4.4 AnonymousAuthenticationFilter</h3><p>匿名认证过滤器，可能有人会想：匿名了还有身份？我自己对于 Anonymous 匿名身份的理解是 Spirng Security 为了整体逻辑的统一性，即使是未通过认证的用户，也给予了一个匿名身份。而 <code>AnonymousAuthenticationFilter</code> 该过滤器的位置也是非常的科学的，它位于常用的身份认证过滤器（如 <code>UsernamePasswordAuthenticationFilter</code>、<code>BasicAuthenticationFilter</code>、<code>RememberMeAuthenticationFilter</code>）之后，意味着只有在上述身份过滤器执行完毕后，SecurityContext 依旧没有用户信息，<code>AnonymousAuthenticationFilter</code> 该过滤器才会有意义 —- 基于用户一个匿名身份。</p>
<h4 id="源码分析-2"><a href="#源码分析-2" class="headerlink" title="源码分析"></a>源码分析</h4><p><code>org.springframework.security.web.authentication.AnonymousAuthenticationFilter</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnonymousAuthenticationFilter</span> <span class="keyword">extends</span> <span class="title">GenericFilterBean</span> <span class="keyword">implements</span></span></span><br><span class="line"><span class="class">      <span class="title">InitializingBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> AuthenticationDetailsSource&lt;HttpServletRequest, ?&gt; authenticationDetailsSource = <span class="keyword">new</span> WebAuthenticationDetailsSource();</span><br><span class="line">   <span class="keyword">private</span> String key;</span><br><span class="line">   <span class="keyword">private</span> Object principal;</span><br><span class="line">   <span class="keyword">private</span> List&lt;GrantedAuthority&gt; authorities;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">// 自动创建一个 &quot;anonymousUser&quot; 的匿名用户, 其具有 ANONYMOUS 角色</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">AnonymousAuthenticationFilter</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>(key, <span class="string">&quot;anonymousUser&quot;</span>, AuthorityUtils.createAuthorityList(<span class="string">&quot;ROLE_ANONYMOUS&quot;</span>));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> key key 用来识别该过滤器创建的身份</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> principal principal 代表匿名用户的身份</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> authorities authorities 代表匿名用户的权限集合</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">AnonymousAuthenticationFilter</span><span class="params">(String key, Object principal,</span></span></span><br><span class="line"><span class="function"><span class="params">         List&lt;GrantedAuthority&gt; authorities)</span> </span>&#123;</span><br><span class="line">      Assert.hasLength(key, <span class="string">&quot;key cannot be null or empty&quot;</span>);</span><br><span class="line">      Assert.notNull(principal, <span class="string">&quot;Anonymous authentication principal must be set&quot;</span>);</span><br><span class="line">      Assert.notNull(authorities, <span class="string">&quot;Anonymous authorities must be set&quot;</span>);</span><br><span class="line">      <span class="keyword">this</span>.key = key;</span><br><span class="line">      <span class="keyword">this</span>.principal = principal;</span><br><span class="line">      <span class="keyword">this</span>.authorities = authorities;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   ...</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest req, ServletResponse res, FilterChain chain)</span></span></span><br><span class="line"><span class="function">         <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">      <span class="comment">// 过滤器链都执行到匿名认证过滤器这儿了还没有身份信息，塞一个匿名身份进去</span></span><br><span class="line">      <span class="keyword">if</span> (SecurityContextHolder.getContext().getAuthentication()== <span class="keyword">null</span>) &#123;</span><br><span class="line">         SecurityContextHolder.getContext().setAuthentication(</span><br><span class="line">               createAuthentication((HttpServletRequest) req));</span><br><span class="line">      &#125;</span><br><span class="line">      chain.doFilter(req, res);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> Authentication <span class="title">createAuthentication</span><span class="params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">     <span class="comment">// 创建一个 AnonymousAuthenticationToken</span></span><br><span class="line">      AnonymousAuthenticationToken auth = <span class="keyword">new</span> AnonymousAuthenticationToken(key,</span><br><span class="line">            principal, authorities);</span><br><span class="line">      auth.setDetails(authenticationDetailsSource.buildDetails(request));</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> auth;</span><br><span class="line">   &#125;</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实对比 AnonymousAuthenticationFilter 和 UsernamePasswordAuthenticationFilter 就可以发现一些门道了，UsernamePasswordAuthenticationToken 对应 AnonymousAuthenticationToken，他们都是 Authentication 的实现类，而 Authentication 则是被 SecurityContextHolder(SecurityContext) 持有的，一切都被串联在了一起。</p>
<h3 id="4-5-ExceptionTranslationFilter"><a href="#4-5-ExceptionTranslationFilter" class="headerlink" title="4.5 ExceptionTranslationFilter"></a>4.5 ExceptionTranslationFilter</h3><p>ExceptionTranslationFilter 异常转换过滤器位于整个 springSecurityFilterChain 的后方，用来转换整个链路中出现的异常，将其转化，顾名思义，转化以意味本身并不处理。一般其只处理两大类异常：AccessDeniedException 访问异常和 AuthenticationException 认证异常。</p>
<p>这个过滤器非常重要，因为它将 Java 中的异常和 HTTP 的响应连接在了一起，这样在处理异常时，我们不用考虑密码错误该跳到什么页面，账号锁定该如何，只需要关注自己的业务逻辑，抛出相应的异常便可。如果该过滤器检测到 AuthenticationException，则将会交给内部的 AuthenticationEntryPoint 去处理，如果检测到 AccessDeniedException，需要先判断当前用户是不是匿名用户，如果是匿名访问，则和前面一样运行 AuthenticationEntryPoint，否则会委托给 AccessDeniedHandler 去处理，而 AccessDeniedHandler 的默认实现，是 AccessDeniedHandlerImpl。所以 ExceptionTranslationFilter 内部的 AuthenticationEntryPoint 是至关重要的，顾名思义：认证的入口点。</p>
<h4 id="源码分析-3"><a href="#源码分析-3" class="headerlink" title="源码分析"></a>源码分析</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExceptionTranslationFilter</span> <span class="keyword">extends</span> <span class="title">GenericFilterBean</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 处理异常转换的核心方法</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleSpringSecurityException</span><span class="params">(HttpServletRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">        HttpServletResponse response, FilterChain chain, RuntimeException exception)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (exception <span class="keyword">instanceof</span> AuthenticationException) &#123;</span><br><span class="line">       	<span class="comment">// 重定向到登录端点</span></span><br><span class="line">        sendStartAuthentication(request, response, chain,</span><br><span class="line">              (AuthenticationException) exception);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">else</span> <span class="keyword">if</span> (exception <span class="keyword">instanceof</span> AccessDeniedException) &#123;</span><br><span class="line">        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();</span><br><span class="line">        <span class="keyword">if</span> (authenticationTrustResolver.isAnonymous(authentication) || authenticationTrustResolver.isRememberMe(authentication)) &#123;</span><br><span class="line">		  <span class="comment">// 重定向到登录端点</span></span><br><span class="line">           sendStartAuthentication(</span><br><span class="line">                 request,</span><br><span class="line">                 response,</span><br><span class="line">                 chain,</span><br><span class="line">                 <span class="keyword">new</span> InsufficientAuthenticationException(</span><br><span class="line">                       <span class="string">&quot;Full authentication is required to access this resource&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="comment">// 交给 accessDeniedHandler 处理</span></span><br><span class="line">           accessDeniedHandler.handle(request, response,</span><br><span class="line">                 (AccessDeniedException) exception);</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>剩下的便是要搞懂 AuthenticationEntryPoint 和 AccessDeniedHandler 就可以了。</p>
<p><img src="https://image.cnkirito.cn/QQ%E5%9B%BE%E7%89%8720170929231608.png" alt="AuthenticationEntryPoint"></p>
<p>选择了几个常用的登录端点，以其中第一个为例来介绍，看名字就能猜到是认证失败之后，让用户跳转到登录页面。还记得我们一开始怎么配置表单登录页面的吗？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebSecurity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebSecurityConfig</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        http</span><br><span class="line">            .authorizeRequests()</span><br><span class="line">                .antMatchers(<span class="string">&quot;/&quot;</span>, <span class="string">&quot;/home&quot;</span>).permitAll()</span><br><span class="line">                .anyRequest().authenticated()</span><br><span class="line">                .and()</span><br><span class="line">            .formLogin()<span class="comment">//FormLoginConfigurer</span></span><br><span class="line">                .loginPage(<span class="string">&quot;/login&quot;</span>)</span><br><span class="line">                .permitAll()</span><br><span class="line">                .and()</span><br><span class="line">            .logout()</span><br><span class="line">                .permitAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们顺着 formLogin 返回的 FormLoginConfigurer 往下找，看看能发现什么，最终在 FormLoginConfigurer 的父类 AbstractAuthenticationFilterConfigurer 中有了不小的收获：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractAuthenticationFilterConfigurer</span> <span class="keyword">extends</span> ...</span>&#123;</span><br><span class="line">   ...</span><br><span class="line">   <span class="comment">//formLogin 不出所料配置了 AuthenticationEntryPoint</span></span><br><span class="line">   <span class="keyword">private</span> LoginUrlAuthenticationEntryPoint authenticationEntryPoint;</span><br><span class="line">   <span class="comment">// 认证失败的处理器</span></span><br><span class="line">   <span class="keyword">private</span> AuthenticationFailureHandler failureHandler;</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>具体如何配置的就不看了，我们得出了结论，formLogin() 配置了之后最起码做了两件事，其一，为 UsernamePasswordAuthenticationFilter 设置了相关的配置，其二配置了 AuthenticationEntryPoint。</p>
<p>登录端点还有 Http401AuthenticationEntryPoint，Http403ForbiddenEntryPoint 这些都是很简单的实现，有时候我们访问受限页面，又没有配置登录，就看到了一个空荡荡的默认错误页面，上面显示着 401,403，就是这两个入口起了作用。</p>
<p>还剩下一个 AccessDeniedHandler 访问决策器未被讲解，简单提一下：AccessDeniedHandlerImpl 这个默认实现类会根据 errorPage 和状态码来判断，最终决定跳转的页面</p>
<p><code>org.springframework.security.web.access.AccessDeniedHandlerImpl#handle</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(HttpServletRequest request, HttpServletResponse response,</span></span></span><br><span class="line"><span class="function"><span class="params">      AccessDeniedException accessDeniedException)</span> <span class="keyword">throws</span> IOException,</span></span><br><span class="line"><span class="function">      ServletException </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (!response.isCommitted()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (errorPage != <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="comment">// Put exception into request scope (perhaps of use to a view)</span></span><br><span class="line">         request.setAttribute(WebAttributes.ACCESS_DENIED_403,</span><br><span class="line">               accessDeniedException);</span><br><span class="line">         <span class="comment">// Set the 403 status code.</span></span><br><span class="line">         response.setStatus(HttpServletResponse.SC_FORBIDDEN);</span><br><span class="line">         <span class="comment">// forward to error page.</span></span><br><span class="line">         RequestDispatcher dispatcher = request.getRequestDispatcher(errorPage);</span><br><span class="line">         dispatcher.forward(request, response);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">         response.sendError(HttpServletResponse.SC_FORBIDDEN,</span><br><span class="line">               accessDeniedException.getMessage());</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-6-FilterSecurityInterceptor"><a href="#4-6-FilterSecurityInterceptor" class="headerlink" title="4.6 FilterSecurityInterceptor"></a>4.6 FilterSecurityInterceptor</h3><p>想想整个认证安全控制流程还缺了什么？我们已经有了认证，有了请求的封装，有了 Session 的关联… 还缺一个：由什么控制哪些资源是受限的，这些受限的资源需要什么权限，需要什么角色… 这一切和访问控制相关的操作，都是由 FilterSecurityInterceptor 完成的。</p>
<p>FilterSecurityInterceptor 的工作流程用笔者的理解可以理解如下：FilterSecurityInterceptor 从 SecurityContextHolder 中获取 Authentication 对象，然后比对用户拥有的权限和资源所需的权限。前者可以通过 Authentication 对象直接获得，而后者则需要引入我们之前一直未提到过的两个类：SecurityMetadataSource，AccessDecisionManager。理解清楚决策管理器的整个创建流程和 SecurityMetadataSource 的作用需要花很大一笔功夫，这里，暂时只介绍其大概的作用。</p>
<p>在 JavaConfig 的配置中，我们通常如下配置路径的访问控制：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">	http</span><br><span class="line">		.authorizeRequests()</span><br><span class="line">			.antMatchers(<span class="string">&quot;/resources/**&quot;</span>, <span class="string">&quot;/signup&quot;</span>, <span class="string">&quot;/about&quot;</span>).permitAll()</span><br><span class="line">             .antMatchers(<span class="string">&quot;/admin/**&quot;</span>).hasRole(<span class="string">&quot;ADMIN&quot;</span>)</span><br><span class="line">             .antMatchers(<span class="string">&quot;/db/**&quot;</span>).access(<span class="string">&quot;hasRole(&#x27;ADMIN&#x27;) and hasRole(&#x27;DBA&#x27;)&quot;</span>)</span><br><span class="line">             .anyRequest().authenticated()</span><br><span class="line">			.withObjectPostProcessor(<span class="keyword">new</span> ObjectPostProcessor&lt;FilterSecurityInterceptor&gt;() &#123;</span><br><span class="line">				<span class="keyword">public</span> &lt;O extends FilterSecurityInterceptor&gt; <span class="function">O <span class="title">postProcess</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">						O fsi)</span> </span>&#123;</span><br><span class="line">					fsi.setPublishAuthorizationSuccess(<span class="keyword">true</span>);</span><br><span class="line">					<span class="keyword">return</span> fsi;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 ObjectPostProcessor 的泛型中看到了 FilterSecurityInterceptor，以笔者的经验，目前并没有太多机会需要修改 FilterSecurityInterceptor 的配置。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本篇文章在介绍过滤器时，顺便进行了一些源码的分析，目的是方便理解整个 Spring Security 的工作流。伴随着整个过滤器链的介绍，安全框架的轮廓应该已经浮出水面了，下面的章节，主要打算通过自定义一些需求，再次分析其他组件的源码，学习应该如何改造 Spring Security，为我们所用。</p>
<p>** 欢迎关注我的微信公众号：「Kirito 的技术分享」，关于文章的任何疑问都会得到回复，带来更多 Java 相关的技术分享。**</p>
<p><img src="https://image.cnkirito.cn/qrcode_for_gh_c06057be7960_258%20%281%29.jpg" alt="关注微信公众号"></p>
</div><div class="article-licensing box"><div class="licensing-title"><p>Spring Security(四)-- 核心过滤器源码分析</p><p><a href="https://www.cnkirito.moe/spring-security-4/">https://www.cnkirito.moe/spring-security-4/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>徐靖峰</p></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2017-09-30</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2025-07-01</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icon" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a><a class="icon" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a><a class="icon" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><hr style="height:1px;margin:1rem 0"><div class="level is-mobile is-flex"><div class="article-tags is-size-7 is-uppercase"><i class="fas fa-tags has-text-grey"></i> <a class="link-muted" rel="tag" href="/tags/Spring-Security/">Spring Security </a></div></div><!--!--></article></div><div class="card"><div class="card-content"><h3 class="menu-label has-text-centered">喜欢这篇文章？打赏一下作者吧</h3><div class="buttons is-centered"><a class="button donate" data-type="alipay"><span class="icon is-small"><i class="fab fa-alipay"></i></span><span>支付宝</span><span class="qrcode"><img src="/img/alipay.png" alt="支付宝"></span></a><a class="button donate" data-type="wechat"><span class="icon is-small"><i class="fab fa-weixin"></i></span><span>微信</span><span class="qrcode"><img src="/img/wechatpay.png" alt="微信"></span></a></div></div></div><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/spring-security-5/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">Spring Security(五)-- 动手实现一个 IP_Login</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/project-rules-2/"><span class="level-item">警惕不规范的变量命名</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><!--!--><div><script src="https://readmore.openwrite.cn/js/readmore.js" type="text/javascript"></script>
            <script>
                const btw = new BTWPlugin();
                btw.init({
                    id: "article-content",
                    blogId: '10053-1610820399501-222',
                    name: 'Kirito的技术分享',
                    qrcode: 'http://image.cnkirito.cn/qrcode_for_gh_c06057be7960_258%20%281%29.jpg',
                    keyword: 'more'
                });
                var rm_btn = $('#read-more-btn');
                rm_btn.html('~阅读全文~人机检测~');
            </script>
            </div></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/avatar.png" alt="徐靖峰"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">徐靖峰</p><p class="is-size-6 is-block">阿里巴巴中间件研发</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>中国·杭州</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">177</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">22</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">77</p></a></div></div></nav><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/wechat_public.jpg" alt="Kirito的技术分享"></figure><div class="level"><a class="level-item button is-primary is-rounded" target="_blank" rel="noopener">↑关注微信公众号↑</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/lexburner"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="WeChat" href="/img/wechat_public.jpg"><i class="fab fa-weixin"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="RSS" href="/atom.xml"><i class="fas fa-rss"></i></a></div></div></div><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="level is-mobile" href="#4-过滤器详解"><span class="level-left"><span class="level-item">1</span><span class="level-item">4 过滤器详解</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#4-1-核心过滤器概述"><span class="level-left"><span class="level-item">1.1</span><span class="level-item">4.1 核心过滤器概述</span></span></a></li><li><a class="level is-mobile" href="#4-2-SecurityContextPersistenceFilter"><span class="level-left"><span class="level-item">1.2</span><span class="level-item">4.2 SecurityContextPersistenceFilter</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#源码分析"><span class="level-left"><span class="level-item">1.2.1</span><span class="level-item">源码分析</span></span></a></li></ul></li><li><a class="level is-mobile" href="#4-3-UsernamePasswordAuthenticationFilter"><span class="level-left"><span class="level-item">1.3</span><span class="level-item">4.3 UsernamePasswordAuthenticationFilter</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#源码分析-1"><span class="level-left"><span class="level-item">1.3.1</span><span class="level-item">源码分析</span></span></a></li></ul></li><li><a class="level is-mobile" href="#4-4-AnonymousAuthenticationFilter"><span class="level-left"><span class="level-item">1.4</span><span class="level-item">4.4 AnonymousAuthenticationFilter</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#源码分析-2"><span class="level-left"><span class="level-item">1.4.1</span><span class="level-item">源码分析</span></span></a></li></ul></li><li><a class="level is-mobile" href="#4-5-ExceptionTranslationFilter"><span class="level-left"><span class="level-item">1.5</span><span class="level-item">4.5 ExceptionTranslationFilter</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#源码分析-3"><span class="level-left"><span class="level-item">1.5.1</span><span class="level-item">源码分析</span></span></a></li></ul></li><li><a class="level is-mobile" href="#4-6-FilterSecurityInterceptor"><span class="level-left"><span class="level-item">1.6</span><span class="level-item">4.6 FilterSecurityInterceptor</span></span></a></li><li><a class="level is-mobile" href="#总结"><span class="level-left"><span class="level-item">1.7</span><span class="level-item">总结</span></span></a></li></ul></li></ul></div></div><script src="/js/toc.js" defer></script></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/avatar.png" alt="徐靖峰|个人博客" height="28"></a><p class="is-size-7"><span>&copy; 2025 徐靖峰</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><div id="outdated"><h6>Your browser is out-of-date!</h6><p>Update your browser to view this website correctly.&amp;npsb;<a id="btnUpdateBrowser" target="_blank" rel="noopener" href="http://outdatedbrowser.com/">Update my browser now </a></p><p class="last"><a href="#" id="btnCloseUpdateBrowser" title="Close">×</a></p></div><script src="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.js" defer></script><script>window.addEventListener("load", function () {
            outdatedBrowser({
                bgColor: '#f25648',
                color: '#ffffff',
                lowerThan: 'object-fit' // display on IE11 or below
            });
        });</script><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>