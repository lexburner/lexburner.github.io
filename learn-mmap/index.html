<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>重新认识 Java 中的内存映射（mmap） - 徐靖峰|个人博客</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="Kirito的技术分享"><meta name="msapplication-TileImage" content="/img/avatar.png"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Kirito的技术分享"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="mmap 基础概念mmap 是一种内存映射文件的方法，即将一个文件映射到进程的地址空间，实现文件磁盘地址和一段进程虚拟地址的映射。实现这样的映射关系后，进程就可以采用指针的方式读写操作这一段内存，而系统会自动回写脏页到对应的文件磁盘上，即完成了对文件的操作而不必再调用 read,write 等系统调用函数。相反，内核空间对这段区域的修改也直接反映用户空间，从而可以实现不同进程间的文件共享。  操作"><meta property="og:type" content="blog"><meta property="og:title" content="重新认识 Java 中的内存映射（mmap）"><meta property="og:url" content="https://www.cnkirito.moe/learn-mmap/"><meta property="og:site_name" content="徐靖峰|个人博客"><meta property="og:description" content="mmap 基础概念mmap 是一种内存映射文件的方法，即将一个文件映射到进程的地址空间，实现文件磁盘地址和一段进程虚拟地址的映射。实现这样的映射关系后，进程就可以采用指针的方式读写操作这一段内存，而系统会自动回写脏页到对应的文件磁盘上，即完成了对文件的操作而不必再调用 read,write 等系统调用函数。相反，内核空间对这段区域的修改也直接反映用户空间，从而可以实现不同进程间的文件共享。  操作"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://image.cnkirito.cn/200501092691998.png"><meta property="og:image" content="https://image.cnkirito.cn/0_1291965816Su3B.gif"><meta property="article:published_time" content="2021-11-08T11:00:24.000Z"><meta property="article:modified_time" content="2025-12-22T07:26:28.108Z"><meta property="article:author" content="徐靖峰"><meta property="article:tag" content="文件IO"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="https://image.cnkirito.cn/200501092691998.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://www.cnkirito.moe/learn-mmap/"},"headline":"重新认识 Java 中的内存映射（mmap）","image":["https://image.cnkirito.cn/200501092691998.png","https://image.cnkirito.cn/0_1291965816Su3B.gif"],"datePublished":"2021-11-08T11:00:24.000Z","dateModified":"2025-12-22T07:26:28.108Z","author":{"@type":"Person","name":"徐靖峰"},"description":"mmap 基础概念mmap 是一种内存映射文件的方法，即将一个文件映射到进程的地址空间，实现文件磁盘地址和一段进程虚拟地址的映射。实现这样的映射关系后，进程就可以采用指针的方式读写操作这一段内存，而系统会自动回写脏页到对应的文件磁盘上，即完成了对文件的操作而不必再调用 read,write 等系统调用函数。相反，内核空间对这段区域的修改也直接反映用户空间，从而可以实现不同进程间的文件共享。  操作"}</script><link rel="canonical" href="https://www.cnkirito.moe/learn-mmap/"><link rel="icon" href="/img/avatar.png"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.12.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><script src="https://www.googletagmanager.com/gtag/js?id=UA-118574570-1" async></script><script>window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
    
        gtag('config', 'UA-118574570-1');</script><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.css"><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><!--!--><!--!--><meta name="generator" content="Hexo 5.4.0"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/avatar.png" alt="徐靖峰|个人博客" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/.">主页</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/archives">归档</a><a class="navbar-item" href="/about">关于</a><a class="navbar-item" target="_blank" rel="noopener" href="https://github.com/YunaiV/onemall">开源项目</a></div><div class="navbar-end"><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-9-widescreen"><div class="card"><article class="card-content article" id="article-content" role="article"><h1 class="title is-size-3 is-size-4-mobile has-text-weight-semibold article-main-title"><span class="has-text-dark"><i class="fas fa-angle-double-right"></i>重新认识 Java 中的内存映射（mmap）</span></h1><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><i class="far fa-calendar-alt"> </i><time dateTime="${date_xml(page.date)}" title="${date_xml(page.date)}">2021-11-08</time></span><span class="level-item is-hidden-mobile"><i class="far fa-calendar-check"> </i><time dateTime="${date_xml(page.updated)}" title="${date_xml(page.updated)}">2025-12-22</time></span><span class="level-item"><a class="link-muted" href="/categories/%E6%80%A7%E8%83%BD%E6%8C%91%E6%88%98%E8%B5%9B/">性能挑战赛</a></span><span class="level-item">23 分钟读完 (大约3446个字)</span></div></div><div class="content"><h2 id="mmap-基础概念"><a href="#mmap-基础概念" class="headerlink" title="mmap 基础概念"></a>mmap 基础概念</h2><p>mmap 是一种内存映射文件的方法，即将一个文件映射到进程的地址空间，实现文件磁盘地址和一段进程虚拟地址的映射。实现这样的映射关系后，进程就可以采用指针的方式读写操作这一段内存，而系统会自动回写脏页到对应的文件磁盘上，即完成了对文件的操作而不必再调用 read,write 等系统调用函数。相反，内核空间对这段区域的修改也直接反映用户空间，从而可以实现不同进程间的文件共享。</p>
<p><img src="https://image.cnkirito.cn/200501092691998.png" alt="mmap工作原理"></p>
<p>操作系统提供了这么一系列 mmap 的配套函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">mmap</span><span class="params">(<span class="keyword">void</span> *start, <span class="keyword">size_t</span> length, <span class="keyword">int</span> prot, <span class="keyword">int</span> flags, <span class="keyword">int</span> fd, <span class="keyword">off_t</span> offset)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">munmap</span><span class="params">( <span class="keyword">void</span> * addr, <span class="keyword">size_t</span> len)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">msync</span><span class="params">( <span class="keyword">void</span> *addr, <span class="keyword">size_t</span> len, <span class="keyword">int</span> flags)</span></span>;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h2 id="Java-中的-mmap"><a href="#Java-中的-mmap" class="headerlink" title="Java 中的 mmap"></a>Java 中的 mmap</h2><p>Java 中原生读写方式大概可以被分为三种：普通 IO，FileChannel（文件通道），mmap（内存映射）。区分他们也很简单，例如 FileWriter,FileReader 存在于 java.io 包中，他们属于普通 IO；FileChannel 存在于 java.nio 包中，也是 Java 最常用的文件操作类；而今天的主角 mmap，则是由 FileChannel 调用 map 方法衍生出来的一种特殊读写文件的方式，被称之为内存映射。</p>
<p>mmap 的使用方式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FileChannel fileChannel = <span class="keyword">new</span> RandomAccessFile(<span class="keyword">new</span> File(<span class="string">&quot;db.data&quot;</span>), <span class="string">&quot;rw&quot;</span>).getChannel();</span><br><span class="line">MappedByteBuffer mappedByteBuffer = fileChannel.map(FileChannel.MapMode.READ_WRITE, <span class="number">0</span>, filechannel.size();</span><br></pre></td></tr></table></figure>

<p><strong>MappedByteBuffer</strong> 便是 Java 中的 mmap 操作类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 写</span></span><br><span class="line"><span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span>];</span><br><span class="line"><span class="keyword">int</span> position = <span class="number">8</span>;</span><br><span class="line"><span class="comment">// 从当前 mmap 指针的位置写入 4b 的数据</span></span><br><span class="line">mappedByteBuffer.put(data);</span><br><span class="line"><span class="comment">// 指定 position 写入 4b 的数据</span></span><br><span class="line">MappedByteBuffer subBuffer = mappedByteBuffer.slice();</span><br><span class="line">subBuffer.position(position);</span><br><span class="line">subBuffer.put(data);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读</span></span><br><span class="line"><span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span>];</span><br><span class="line"><span class="keyword">int</span> position = <span class="number">8</span>;</span><br><span class="line"><span class="comment">// 从当前 mmap 指针的位置读取 4b 的数据</span></span><br><span class="line">mappedByteBuffer.get(data)；</span><br><span class="line"><span class="comment">// 指定 position 读取 4b 的数据</span></span><br><span class="line">MappedByteBuffer subBuffer = mappedByteBuffer.slice();</span><br><span class="line">subBuffer.position(position);</span><br><span class="line">subBuffer.get(data);</span><br></pre></td></tr></table></figure>

<h2 id="mmap-不是银弹"><a href="#mmap-不是银弹" class="headerlink" title="mmap 不是银弹"></a>mmap 不是银弹</h2><p>促使我写这一篇文章的一大动力，来自于网络中很多关于 mmap 错误的认知。初识 mmap，很多文章提到 mmap 适用于处理大文件的场景，现在回过头看，其实这种观点是非常荒唐的，希望通过此文能够澄清 mmap 本来的面貌。</p>
<p>FileChannel 与 mmap 同时存在，大概率说明两者都有其合适的使用场景，而事实也的确如此。在看待二者时，可以将其看待成实现文件 IO 的两种工具，工具本身没有好坏，主要还是看使用场景。</p>
<h2 id="mmap-vs-FileChannel"><a href="#mmap-vs-FileChannel" class="headerlink" title="mmap vs FileChannel"></a>mmap vs FileChannel</h2><p>这一节，详细介绍一下 FileChannel 和 mmap 在进行文件 IO 的一些异同点。</p>
<h3 id="pageCache"><a href="#pageCache" class="headerlink" title="pageCache"></a>pageCache</h3><p>FileChannel 和 mmap 的读写都经过 pageCache，或者更准确的说法是通过 <code>vmstat</code> 观测到的 <code>cache</code> 这一部分内存，而非用户空间的内存。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----</span><br><span class="line"> r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st</span><br><span class="line"> 3  0      0 4622324  40736 351384    0    0     0     0 2503  200 50  1 50  0  0</span><br></pre></td></tr></table></figure>

<p>至于说 mmap 映射的这部分内存能不能称之为 pageCache，我并没有去调研过，不过在操作系统看来，他们并没有太多的区别，这部分 cache 都是内核在控制。后面本文也统一称 mmap 出来的内存为 pageCache。</p>
<h3 id="缺页中断"><a href="#缺页中断" class="headerlink" title="缺页中断"></a>缺页中断</h3><p>对 Linux 文件 IO 有基础认识的读者，可能对缺页中断这个概念也不会太陌生。mmap 和 FileChannel 都以缺页中断的方式，进行文件读写。</p>
<p>以 mmap 读取 1G 文件为例， <code>fileChannel.map(FileChannel.MapMode.READ_WRITE, 0, _GB);</code> 进行映射是一个消耗极少的操作，此时并不意味着 1G 的文件被读进了 pageCache。只有通过以下方式，才能够确保文件被读进 pageCache。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FileChannel fileChannel = <span class="keyword">new</span> RandomAccessFile(file, <span class="string">&quot;rw&quot;</span>).getChannel();</span><br><span class="line">MappedByteBuffer map = fileChannel.map(MapMode.READ_WRITE, <span class="number">0</span>, _GB);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; _GB; i += _4kb) &#123;</span><br><span class="line">	temp += map.get(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>关于内存对齐的细节在这里就不拓展了，可以详见 java.nio.MappedByteBuffer#load 方法，load 方法也是通过按页访问的方式触发中断</p>
</blockquote>
<p>如下是 pageCache 逐渐增长的过程，共计约增长了 1.034G，说明文件内容此刻已全部 load。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----</span><br><span class="line"> r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st</span><br><span class="line"> 2  0      0 4824640   1056 207912    0    0     0     0 2374  195 50  0 50  0  0</span><br><span class="line"> 2  1      0 4605300   2676 411892    0    0 205256     0 3481 1759 52  2 34 12  0</span><br><span class="line"> 2  1      0 4432560   2676 584308    0    0 172032     0 2655  346 50  1 25 24  0</span><br><span class="line"> 2  1      0 4255080   2684 761104    0    0 176400     0 2754  380 50  1 19 29  0</span><br><span class="line"> 2  3      0 4086528   2688 929420    0    0 167940    40 2699  327 50  1 25 24  0</span><br><span class="line"> 2  2      0 3909232   2692 1106300    0    0 176520     4 2810  377 50  1 23 26  0</span><br><span class="line"> 2  2      0 3736432   2692 1278856    0    0 172172     0 2980  361 50  1 17 31  0</span><br><span class="line"> 3  0      0 3722064   2840 1292776    0    0 14036     0 2757  392 50  1 29 21  0</span><br><span class="line"> 2  0      0 3721784   2840 1292892    0    0   116     0 2621  283 50  1 50  0  0</span><br><span class="line"> 2  0      0 3721996   2840 1292892    0    0     0     0 2478  237 50  0 50  0  0</span><br></pre></td></tr></table></figure>

<p>两个细节：</p>
<ol>
<li>mmap 映射的过程可以理解为一个懒加载， 只有 get() 时才会触发缺页中断</li>
<li>预读大小是有操作系统算法决定的，可以默认当作 4kb，即如果希望懒加载变成实时加载，需要按照 step=4kb 进行一次遍历</li>
</ol>
<p>而 FileChannel 缺页中断的原理也与之相同，都需要借助 PageCache 做一层跳板，完成文件的读写。</p>
<h3 id="内存拷贝次数"><a href="#内存拷贝次数" class="headerlink" title="内存拷贝次数"></a>内存拷贝次数</h3><p>很多言论认为 mmap 相比 FileChannel 少一次复制，我个人觉得还是需要区分场景。</p>
<p>例如需求是从文件首地址读取一个 int，两者所经过的链路其实是一致的：SSD -&gt; pageCache -&gt; 应用内存，mmap 并不会少拷贝一次。</p>
<p>但如果需求是维护一个 100M 的复用 buffer，且涉及到文件 IO，mmap 直接就可以当做是 100M 的 buffer 来用，而不用在进程的内存（用户空间）中再维护一个 100M 的缓冲。</p>
<h3 id="用户态与内核态"><a href="#用户态与内核态" class="headerlink" title="用户态与内核态"></a>用户态与内核态</h3><p><img src="https://image.cnkirito.cn/0_1291965816Su3B.gif" alt="用户态和内核态"></p>
<p>操作系统出于安全考虑，将一些底层的能力进行了封装，提供了系统调用（system call）给用户使用。这里就涉及到“用户态”和“内核态”的切换问题，私认为这里也是很多人概念理解模糊的重灾区，我在此梳理下个人的认知，如有错误也欢迎指正。</p>
<p>先看 FileChannel，下面两段代码，你认为谁更快？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法一: 4kb 刷盘</span></span><br><span class="line">FileChannel fileChannel = <span class="keyword">new</span> RandomAccessFile(file, <span class="string">&quot;rw&quot;</span>).getChannel();</span><br><span class="line">ByteBuffer byteBuffer = ByteBuffer.allocateDirect(_4kb);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; _4kb; i++) &#123;</span><br><span class="line">    byteBuffer.put((<span class="keyword">byte</span>)<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; _GB; i += _4kb) &#123;</span><br><span class="line">    byteBuffer.position(<span class="number">0</span>);</span><br><span class="line">    byteBuffer.limit(_4kb);</span><br><span class="line">    fileChannel.write(byteBuffer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法二: 单字节刷盘</span></span><br><span class="line">FileChannel fileChannel = <span class="keyword">new</span> RandomAccessFile(file, <span class="string">&quot;rw&quot;</span>).getChannel();</span><br><span class="line">ByteBuffer byteBuffer = ByteBuffer.allocateDirect(<span class="number">1</span>);</span><br><span class="line">byteBuffer.put((<span class="keyword">byte</span>)<span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; _GB; i ++) &#123;</span><br><span class="line">    byteBuffer.position(<span class="number">0</span>);</span><br><span class="line">    byteBuffer.limit(<span class="number">1</span>);</span><br><span class="line">    fileChannel.write(byteBuffer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>使用方法一：4kb 缓冲刷盘（常规操作），在我的测试机器上只需要 1.2s 就写完了 1G。而不使用任何缓冲的方法二，几乎是直接卡死，文件增长速度非常缓慢，在等待了 5 分钟还没写完后，中断了测试。</strong></p>
<p>使用写入缓冲区是一个非常经典的优化技巧，用户只需要设置 4kb 整数倍的写入缓冲区，聚合小数据的写入，就可以使得数据从 pageCache 刷盘时，尽可能是 4kb 的整数倍，避免写入放大问题。但这不是这一节的重点，大家有没有想过，pageCache 其实本身也是一层缓冲，实际写入 1byte 并不是同步刷盘的，相当于写入了内存，pageCache 刷盘由操作系统自己决策。那为什么方法二这么慢呢？<strong>主要就在于 filechannel 的 read/write 底层相关联的系统调用，是需要切换内核态和用户态的，注意，这里跟内存拷贝没有任何关系，导致态切换的根本原因是 read/write 关联的系统调用本身</strong>。方法二比方法一多切换了 4096 倍，态的切换成为了瓶颈，导致耗时严重。</p>
<p>阶段总结一下重点，在 DRAM 中设置用户写入缓冲区这一行为有两个意义：</p>
<ol>
<li>方便做 4kb 对齐，ssd 刷盘友好</li>
<li>减少用户态和内核态的切换次数，cpu 友好</li>
</ol>
<p>但 mmap 不同，其底层提供的映射能力不涉及到切换内核态和用户态，注意，这里跟内存拷贝还是没有任何关系，导致态不发生切换的根本原因是 mmap 关联的系统调用本身。验证这一点，也非常容易，我们使用 mmap 实现方法二来看看速度如何：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FileChannel fileChannel = <span class="keyword">new</span> RandomAccessFile(file, <span class="string">&quot;rw&quot;</span>).getChannel();</span><br><span class="line">MappedByteBuffer map = fileChannel.map(MapMode.READ_WRITE, <span class="number">0</span>, _GB);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; _GB; i++) &#123;</span><br><span class="line">		map.put((<span class="keyword">byte</span>)<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在我的测试机器上，花费了 3s，它比 FileChannel + 4kb 缓冲写要慢，但远比 FileChannel 写单字节快。</p>
<p>这里也解释了我之前文章《<a href="https://www.cnkirito.moe/file-io-best-practise/">文件 IO 操作的一些最佳实践</a>》中一个疑问：”一次写入很小量数据的场景使用 mmap 会比 fileChannel 快的多“，其背后的原理就和上述例子一样，在小数据量下，瓶颈不在于 IO，而在于<strong>用户态和内核态的切换</strong>。</p>
<h2 id="mmap-细节补充"><a href="#mmap-细节补充" class="headerlink" title="mmap 细节补充"></a>mmap 细节补充</h2><h3 id="copy-on-write-模式"><a href="#copy-on-write-模式" class="headerlink" title="copy on write 模式"></a>copy on write 模式</h3><p>我们注意到 <code>public abstract MappedByteBuffer map(MapMode mode,long position, long size)</code> 的第一个参数，MapMode 其实有三个值，在网络冲浪的时候，也几乎没有找到讲解 MapMode 的文章。MapMode 有三个枚举值 <code>READ_WRITE</code>、<code>READ_ONLY</code>、<code>PRIVATE</code>，大多数时候使用的可能是 <code>READ_WRITE</code>，而 <code>READ_ONLY</code> 不过是限制了 <code>WRITE</code> 而已，很容易理解，但这个 <code>PRIVATE</code> 身上似乎有一层神秘的面纱。</p>
<p>实际上 <code>PRIVATE</code> 模式正是 mmap 的 copy on write 模式，当使用 MapMode.PRIVATE 去映射文件时，你会获得以下的特性：</p>
<ol>
<li>其他任何方式对文件的修改，会直接反映在当前 mmap 映射中。</li>
<li>private mmap 之后自身的 put 行为，会触发复制，形成自己的副本，任何修改不会会刷到文件中，也不再感知该文件该页的改动。</li>
</ol>
<p>俗称：copy on write。</p>
<p>这有什么用呢？重点就在于任何修改都不会回刷文件。其一，你可以获得一个文件副本，如果你正好有这个需求，直接可以使用 PRIVATE 模式去进行映射，其二，令人有点小激动的场景，你获得了一块真正的 PageCache，不用担心它会被操作系统刷盘造成 overhead。假设你的机器配置如下：机器内存 9G，JVM 参数设置为 6G，堆外限制为 2G，那剩下的 1G 只能被内核态使用，如果想被用户态的程序利用起来，就可以使用 mmap 的 copy on write 模式，这不会占用你的堆内内存或者堆外内存。</p>
<h3 id="回收-mmap-内存"><a href="#回收-mmap-内存" class="headerlink" title="回收 mmap 内存"></a>回收 mmap 内存</h3><p>更正之前博文关于 mmap 内存回收的一个错误说法，回收 mmap 很简单</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">((DirectBuffer) mmap).cleaner().clean();</span><br></pre></td></tr></table></figure>

<p>mmap 的生命中简单可以分为：map（映射），get/load （缺页中断），clean（回收）。一个实用的技巧是动态分配的内存映射区域，在读取过后，可以异步回收掉。</p>
<h2 id="mmap-使用场景"><a href="#mmap-使用场景" class="headerlink" title="mmap 使用场景"></a>mmap 使用场景</h2><h3 id="使用-mmap-处理小数据的频繁读写"><a href="#使用-mmap-处理小数据的频繁读写" class="headerlink" title="使用 mmap 处理小数据的频繁读写"></a>使用 mmap 处理小数据的频繁读写</h3><p>如果 IO 非常频繁，数据却非常小，推荐使用 mmap，以避免 FileChannel 导致的切态问题。例如索引文件的追加写。</p>
<h3 id="mmap-缓存"><a href="#mmap-缓存" class="headerlink" title="mmap 缓存"></a>mmap 缓存</h3><p>当使用 FileChannel 进行文件读写时，往往需要一块写入缓存以达到聚合的目的，最常使用的是堆内/堆外内存，但他们都有一个问题，即当进程挂掉后，堆内/堆外内存会立刻丢失，这一部分没有落盘的数据也就丢了。而使用 mmap 作为缓存，会直接存储在 pageCache 中，不会导致数据丢失，尽管这只能规避进程被 kill 这种情况，无法规避掉电。</p>
<h3 id="小文件的读写"><a href="#小文件的读写" class="headerlink" title="小文件的读写"></a>小文件的读写</h3><p>恰恰和网传的很多言论相反，mmap 由于其不切态的特性，特别适合顺序读写，但由于 <code>sun.nio.ch.FileChannelImpl#map(MapMode mode, long position, long size)</code>  中 size 的限制，只能传递一个 int 值，所以，单次 map 单个文件的长度不能超过 2G，如果将 2G 作为文件大 or 小的阈值，那么小于 2G 的文件使用 mmap 来读写一般来说是有优势的。在 RocketMQ 中也利用了这一点，为了能够方便的使用 mmap，将 commitLog 的大小按照 1G 来进行切分。对的，忘记说了，RocketMQ 等消息队列一直在使用 mmap。</p>
<h3 id="cpu-紧俏下的读写"><a href="#cpu-紧俏下的读写" class="headerlink" title="cpu 紧俏下的读写"></a>cpu 紧俏下的读写</h3><p>在大多数场景下，FileChannel 和读写缓冲的组合相比 mmap 要占据优势，或者说不分伯仲，但在 cpu 紧俏下的读写，使用 mmap 进行读写往往能起到优化的效果，它的根据是 mmap 不会出现用户态和内核态的切换，导致 cpu 的不堪重负（但这样承担起动态映射与异步回收内存的开销）。</p>
<h3 id="特殊软硬件因素"><a href="#特殊软硬件因素" class="headerlink" title="特殊软硬件因素"></a>特殊软硬件因素</h3><p>例如持久化内存 Pmem、不同代数的 SSD、不同主频的 CPU、不同核数的 CPU、不同的文件系统、文件系统的挂载方式…等等因素都会影响 mmap 和 filechannel read/write 的快慢，因为他们对应的系统调用是不同的。只有 benchmark 过后，方知快慢。</p>
</div><div class="article-licensing box"><div class="licensing-title"><p>重新认识 Java 中的内存映射（mmap）</p><p><a href="https://www.cnkirito.moe/learn-mmap/">https://www.cnkirito.moe/learn-mmap/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>徐靖峰</p></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2021-11-08</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2025-12-22</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icon" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a><a class="icon" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a><a class="icon" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><hr style="height:1px;margin:1rem 0"><div class="level is-mobile is-flex"><div class="article-tags is-size-7 is-uppercase"><i class="fas fa-tags has-text-grey"></i> <a class="link-muted" rel="tag" href="/tags/%E6%96%87%E4%BB%B6IO/">文件IO </a></div></div><!--!--></article></div><div class="card"><div class="card-content"><h3 class="menu-label has-text-centered">喜欢这篇文章？打赏一下作者吧</h3><div class="buttons is-centered"><a class="button donate" data-type="alipay"><span class="icon is-small"><i class="fab fa-alipay"></i></span><span>支付宝</span><span class="qrcode"><img src="/img/alipay.png" alt="支付宝"></span></a><a class="button donate" data-type="wechat"><span class="icon is-small"><i class="fab fa-weixin"></i></span><span>微信</span><span class="qrcode"><img src="/img/wechatpay.png" alt="微信"></span></a></div></div></div><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/talk-about-blog/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">Kirito 的博客崩了，这次是因为...</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/cloudnative-race-2021-rmq/"><span class="level-item">【参赛总结】第二届云原生编程挑战赛-冷热读写场景的RocketMQ存储系统设计</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><!--!--></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/avatar.png" alt="徐靖峰"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">徐靖峰</p><p class="is-size-6 is-block">阿里巴巴中间件研发</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>中国·杭州</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">180</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">14</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">77</p></a></div></div></nav><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/wechat_public.jpg" alt="Kirito的技术分享"></figure><div class="level"><a class="level-item button is-primary is-rounded" target="_blank" rel="noopener">↑关注微信公众号↑</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/lexburner"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="WeChat" href="/img/wechat_public.jpg"><i class="fab fa-weixin"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="RSS" href="/atom.xml"><i class="fas fa-rss"></i></a></div></div></div><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="level is-mobile" href="#mmap-基础概念"><span class="level-left"><span class="level-item">1</span><span class="level-item">mmap 基础概念</span></span></a></li><li><a class="level is-mobile" href="#Java-中的-mmap"><span class="level-left"><span class="level-item">2</span><span class="level-item">Java 中的 mmap</span></span></a></li><li><a class="level is-mobile" href="#mmap-不是银弹"><span class="level-left"><span class="level-item">3</span><span class="level-item">mmap 不是银弹</span></span></a></li><li><a class="level is-mobile" href="#mmap-vs-FileChannel"><span class="level-left"><span class="level-item">4</span><span class="level-item">mmap vs FileChannel</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#pageCache"><span class="level-left"><span class="level-item">4.1</span><span class="level-item">pageCache</span></span></a></li><li><a class="level is-mobile" href="#缺页中断"><span class="level-left"><span class="level-item">4.2</span><span class="level-item">缺页中断</span></span></a></li><li><a class="level is-mobile" href="#内存拷贝次数"><span class="level-left"><span class="level-item">4.3</span><span class="level-item">内存拷贝次数</span></span></a></li><li><a class="level is-mobile" href="#用户态与内核态"><span class="level-left"><span class="level-item">4.4</span><span class="level-item">用户态与内核态</span></span></a></li></ul></li><li><a class="level is-mobile" href="#mmap-细节补充"><span class="level-left"><span class="level-item">5</span><span class="level-item">mmap 细节补充</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#copy-on-write-模式"><span class="level-left"><span class="level-item">5.1</span><span class="level-item">copy on write 模式</span></span></a></li><li><a class="level is-mobile" href="#回收-mmap-内存"><span class="level-left"><span class="level-item">5.2</span><span class="level-item">回收 mmap 内存</span></span></a></li></ul></li><li><a class="level is-mobile" href="#mmap-使用场景"><span class="level-left"><span class="level-item">6</span><span class="level-item">mmap 使用场景</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#使用-mmap-处理小数据的频繁读写"><span class="level-left"><span class="level-item">6.1</span><span class="level-item">使用 mmap 处理小数据的频繁读写</span></span></a></li><li><a class="level is-mobile" href="#mmap-缓存"><span class="level-left"><span class="level-item">6.2</span><span class="level-item">mmap 缓存</span></span></a></li><li><a class="level is-mobile" href="#小文件的读写"><span class="level-left"><span class="level-item">6.3</span><span class="level-item">小文件的读写</span></span></a></li><li><a class="level is-mobile" href="#cpu-紧俏下的读写"><span class="level-left"><span class="level-item">6.4</span><span class="level-item">cpu 紧俏下的读写</span></span></a></li><li><a class="level is-mobile" href="#特殊软硬件因素"><span class="level-left"><span class="level-item">6.5</span><span class="level-item">特殊软硬件因素</span></span></a></li></ul></li></ul></div></div><script src="/js/toc.js" defer></script></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/avatar.png" alt="徐靖峰|个人博客" height="28"></a><p class="is-size-7"><span>&copy; 2026 徐靖峰</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><div id="outdated"><h6>Your browser is out-of-date!</h6><p>Update your browser to view this website correctly.&amp;npsb;<a id="btnUpdateBrowser" target="_blank" rel="noopener" href="http://outdatedbrowser.com/">Update my browser now </a></p><p class="last"><a href="#" id="btnCloseUpdateBrowser" title="Close">×</a></p></div><script src="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.js" defer></script><script>window.addEventListener("load", function () {
            outdatedBrowser({
                bgColor: '#f25648',
                color: '#ffffff',
                lowerThan: 'object-fit' // display on IE11 or below
            });
        });</script><!--!--><!--!--><!--!--><script src="/js/scroll-animations.js" defer></script><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>