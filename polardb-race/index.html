<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>PolarDB 数据库性能大赛 Java 选手分享 - 徐靖峰|个人博客</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="Kirito的技术分享"><meta name="msapplication-TileImage" content="/img/avatar.png"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Kirito的技术分享"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="1 前言 国际惯例，先报成绩，熬了无数个夜晚，最后依旧被绝杀出了第一页，最终排名第 21 名。前十名的成绩分布为 413.69~416.94，我最终的耗时是 422.43。成绩虽然不是特别亮眼，但与众多参赛选手使用 C++ 作为参赛语言不同，我使用的是 Java，一方面是我 C++ 的能力早已荒废，另一方面是我想验证一下使用 Java 编写存储引擎是否与 C++ 差距巨大 (当然，主要还是前者 Q"><meta property="og:type" content="blog"><meta property="og:title" content="PolarDB 数据库性能大赛 Java 选手分享"><meta property="og:url" content="https://www.cnkirito.moe/polardb-race/"><meta property="og:site_name" content="徐靖峰|个人博客"><meta property="og:description" content="1 前言 国际惯例，先报成绩，熬了无数个夜晚，最后依旧被绝杀出了第一页，最终排名第 21 名。前十名的成绩分布为 413.69~416.94，我最终的耗时是 422.43。成绩虽然不是特别亮眼，但与众多参赛选手使用 C++ 作为参赛语言不同，我使用的是 Java，一方面是我 C++ 的能力早已荒废，另一方面是我想验证一下使用 Java 编写存储引擎是否与 C++ 差距巨大 (当然，主要还是前者 Q"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://image.cnkirito.cn/image-20181210184521001.png"><meta property="og:image" content="https://image.cnkirito.cn/KiritoDB.png"><meta property="og:image" content="https://image.cnkirito.cn/image-20181210204156199.png"><meta property="og:image" content="https://image.cnkirito.cn/image-20181210215200345.png"><meta property="og:image" content="https://image.cnkirito.cn/qrcode_for_gh_c06057be7960_258%20%281%29.jpg"><meta property="article:published_time" content="2018-12-10T10:43:56.000Z"><meta property="article:modified_time" content="2025-05-26T03:18:30.980Z"><meta property="article:author" content="徐靖峰"><meta property="article:tag" content="数据库"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="https://image.cnkirito.cn/image-20181210184521001.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://www.cnkirito.moe/polardb-race/"},"headline":"PolarDB 数据库性能大赛 Java 选手分享","image":["https://image.cnkirito.cn/image-20181210184521001.png","https://image.cnkirito.cn/KiritoDB.png","https://image.cnkirito.cn/image-20181210204156199.png","https://image.cnkirito.cn/image-20181210215200345.png","https://image.cnkirito.cn/qrcode_for_gh_c06057be7960_258%20%281%29.jpg"],"datePublished":"2018-12-10T10:43:56.000Z","dateModified":"2025-05-26T03:18:30.980Z","author":{"@type":"Person","name":"徐靖峰"},"description":"1 前言 国际惯例，先报成绩，熬了无数个夜晚，最后依旧被绝杀出了第一页，最终排名第 21 名。前十名的成绩分布为 413.69~416.94，我最终的耗时是 422.43。成绩虽然不是特别亮眼，但与众多参赛选手使用 C++ 作为参赛语言不同，我使用的是 Java，一方面是我 C++ 的能力早已荒废，另一方面是我想验证一下使用 Java 编写存储引擎是否与 C++ 差距巨大 (当然，主要还是前者 Q"}</script><link rel="canonical" href="https://www.cnkirito.moe/polardb-race/"><link rel="icon" href="/img/avatar.png"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.12.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><script src="https://www.googletagmanager.com/gtag/js?id=UA-118574570-1" async></script><script>window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
    
        gtag('config', 'UA-118574570-1');</script><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.css"><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><!--!--><!--!--><meta name="generator" content="Hexo 5.4.0"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/avatar.png" alt="徐靖峰|个人博客" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/.">主页</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/archives">归档</a><a class="navbar-item" href="/about">关于</a><a class="navbar-item" target="_blank" rel="noopener" href="https://github.com/YunaiV/onemall">开源项目</a></div><div class="navbar-end"><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-9-widescreen"><div class="card"><article class="card-content article" id="article-content" role="article"><h1 class="title is-size-3 is-size-4-mobile has-text-weight-semibold article-main-title"><span class="has-text-dark"><i class="fas fa-angle-double-right"></i>PolarDB 数据库性能大赛 Java 选手分享</span></h1><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><i class="far fa-calendar-alt"> </i><time dateTime="${date_xml(page.date)}" title="${date_xml(page.date)}">2018-12-10</time></span><span class="level-item is-hidden-mobile"><i class="far fa-calendar-check"> </i><time dateTime="${date_xml(page.updated)}" title="${date_xml(page.updated)}">2025-05-26</time></span><span class="level-item"><a class="link-muted" href="/categories/%E6%80%A7%E8%83%BD%E6%8C%91%E6%88%98%E8%B5%9B/">性能挑战赛</a></span><span class="level-item">35 分钟读完 (大约5318个字)</span></div></div><div class="content"><h3 id="1-前言"><a href="#1-前言" class="headerlink" title="1 前言"></a>1 前言</h3><p><img src="https://image.cnkirito.cn/image-20181210184521001.png" alt="排名"></p>
<p>国际惯例，先报成绩，熬了无数个夜晚，最后依旧被绝杀出了第一页，最终排名第 21 名。前十名的成绩分布为 413.69~416.94，我最终的耗时是 422.43。成绩虽然不是特别亮眼，但与众多参赛选手使用 C++ 作为参赛语言不同，我使用的是 Java，一方面是我 C++ 的能力早已荒废，另一方面是我想验证一下使用 Java 编写存储引擎是否与 C++ 差距巨大 (当然，主要还是前者 QAQ)。所以在本文中，我除了介绍整体的架构之外，还会着重笔墨来探讨 Java 编写存储类型应用的一些最佳实践，文末会给出 github 的开源地址。</p>
<span id="more"></span>

<h3 id="2-赛题概览"><a href="#2-赛题概览" class="headerlink" title="2 赛题概览"></a>2 赛题概览</h3><p>比赛总体分成了初赛和复赛两个阶段，整体要求实现一个简化、高效的 kv 存储引擎</p>
<p>初赛要求支持 Write、Read 接口。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">byte</span>[] key, <span class="keyword">byte</span>[] value)</span></span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">byte</span>[] read(<span class="keyword">byte</span>[] key);</span><br></pre></td></tr></table></figure>

<p>复赛在初赛题目基础上，还需要额外实现一个 Range 接口。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">range</span><span class="params">(<span class="keyword">byte</span>[] lower, <span class="keyword">byte</span>[] upper, AbstractVisitor visitor)</span></span>;</span><br></pre></td></tr></table></figure>

<p>程序评测逻辑 分为 2 个阶段：<br>1）Recover 正确性评测：<br>此阶段评测程序会并发写入特定数据（key 8B、value 4KB）同时进行任意次 kill -9 来模拟进程意外退出（参赛引擎需要保证进程意外退出时数据持久化不丢失），接着重新打开 DB，调用 Read、Range 接口来进行正确性校验</p>
<p>2）性能评测</p>
<ul>
<li> 随机写入：64 个线程并发随机写入，每个线程使用 Write 各写 100 万次随机数据（key 8B、value 4KB）</li>
<li> 随机读取：64 个线程并发随机读取，每个线程各使用 Read 读取 100 万次随机数据</li>
<li>顺序读取：64 个线程并发顺序读取，每个线程各使用 Range 有序（增序）遍历全量数据 2 次<br>注：</li>
</ul>
<p>  2.2 阶段会对所有读取的 kv 校验是否匹配，如不通过则终止，评测失败；<br>  2.3 阶段除了对迭代出来每条的 kv 校 验是否匹配外，还会额外校验是否严格字典序递增，如不通过则终止，评测失败。</p>
<p>语言限定：C++ &amp; JAVA，一起排名</p>
<h3 id="3-赛题剖析"><a href="#3-赛题剖析" class="headerlink" title="3 赛题剖析"></a>3 赛题剖析</h3><p>关于文件 IO 操作的一些基本常识，我已经在专题文章中进行了介绍，如果你没有浏览那篇文章，建议先行浏览一下：<a href="https://www.cnkirito.moe/file-io-best-practise/">文件 IO 操作的一些最佳实践</a>。再回归赛题，先对赛题中的几个关键词来进行解读。</p>
<h4 id="3-1-key-8B-value-4kb"><a href="#3-1-key-8B-value-4kb" class="headerlink" title="3.1 key 8B, value 4kb"></a>3.1 key 8B, value 4kb</h4><p>key 为固定的 8 字节，因此可使用 long 来表示。</p>
<p>value 为 4kb，这节省了我们很大的工作量，因为 4kb 的整数倍落盘是非常磁盘 IO 友好的。</p>
<p>value 为 4kb 的另一个好处是我们再内存做索引时，可以使用 int 而不是 long，来记录数据的逻辑偏移量：LogicOffset = PhysicalOffset / 4096，可以将 offset 的内存占用量减少一半。</p>
<h4 id="3-2-kill-9-数据不丢失"><a href="#3-2-kill-9-数据不丢失" class="headerlink" title="3.2 kill -9 数据不丢失"></a>3.2 kill -9 数据不丢失</h4><p>首先赛题明确表示会进行 kill -9 并验证数据的一致性，这加大了我们在内存中做 write buffer 的难度。但它并没有要求断电不丢失，这间接地阐释了一点：我们可以使用 pageCache 来做写入缓存，在具体代码中我使用了 PageCache 来充当数据和索引的写入缓冲（两者策略不同）。同时这点也限制了参赛选手，不能使用 AIO 这样的异步落盘方式。</p>
<h4 id="3-3-分阶段测评"><a href="#3-3-分阶段测评" class="headerlink" title="3.3 分阶段测评"></a>3.3 分阶段测评</h4><p>赛题分为了随机写，随机读，顺序读三个阶段，每个阶段都会重新 open，且不会发生随机写到一半校验随机读这样的行为，所以我们在随机写阶段不需要在内存维护索引，而是直接落盘。随机读和顺序读阶段，磁盘均存在数据，open 阶段需要恢复索引，可以使用多线程并发恢复。</p>
<p>** 同时，赛题还有存在一些隐性的测评细节没有披露给大家，但通过测试，我们可以得知这些信息。**</p>
<h4 id="3-4-清空-PageCache-的耗时"><a href="#3-4-清空-PageCache-的耗时" class="headerlink" title="3.4 清空 PageCache 的耗时"></a>3.4 清空 PageCache 的耗时</h4><p>虽然我们可以使用 PageCache，但评测程序在每个阶段之后都使用脚本清空了 PageCache，并且将这部分时间也算进了最终的成绩之中，所以有人感到奇怪：三个阶段的耗时相加比输出出来的成绩要差，其实那几秒便是清空 PageCache 的耗时。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">清理 pagecache (页缓存)</span></span><br><span class="line">sysctl -w vm.drop_caches=1</span><br><span class="line"><span class="meta">#</span><span class="bash">清理 dentries（目录缓存）和 inodes</span></span><br><span class="line">sysctl -w vm.drop_caches=2</span><br><span class="line"><span class="meta">#</span><span class="bash">清理 pagecache、dentries 和 inodes</span></span><br><span class="line">sysctl -w vm.drop_caches=3</span><br></pre></td></tr></table></figure>

<p>这一点启发我们，不能毫无节制的使用 PageCache，也正是因为这一点，一定程度上使得 Direct IO 这一操作成了本次竞赛的银弹。</p>
<h4 id="3-5-key-的分布"><a href="#3-5-key-的分布" class="headerlink" title="3.5 key 的分布"></a>3.5 key 的分布</h4><p>这一个隐性条件可谓是本次比赛的关键，因为它涉及到 Range 部分的架构设计。本次比赛的 key 共计 6400w，但是他们的分布都是 ** 均匀 ** 的，在 <a href="https://www.cnkirito.moe/file-io-best-practise/">《文件 IO 操作的一些最佳实践》</a> 一文中我们已经提到了数据分区的好处，可以大大减少顺序读写的锁冲突，而 key 的分布均匀这一特性，启发我们在做数据分区时，可以按照 key 的搞 n 位来做 hash，从而确保 key 两个分区之间整体有序 (分区内部无序)。实际我尝试了将数据分成 1024、2048 个分区，效果最佳。</p>
<h4 id="3-6-Range-的缓存设计"><a href="#3-6-Range-的缓存设计" class="headerlink" title="3.6 Range 的缓存设计"></a>3.6 Range 的缓存设计</h4><p>赛题要求 64 个线程 Range 两次全量的数据，限时 1h，这也启发了我们，如果不对数据进行缓存，想要在 1h 内完成比赛是不可能的，所以，我们的架构设计应该尽量以 Range 为核心，兼顾随机写和随机读。Range 部分也是最容易拉开差距的一个环节。</p>
<h3 id="4-架构详解"><a href="#4-架构详解" class="headerlink" title="4 架构详解"></a>4 架构详解</h3><p>首先需要明确的是，随机写指的是 key 的写入是随机的，但我们可以根据 key hash，将随机写转换为对应分区文件的顺序写。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * using high ten bit of the given key to determine which file it hits.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HighTenPartitioner</span> <span class="keyword">implements</span> <span class="title">Partitionable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getPartition</span><span class="params">(<span class="keyword">byte</span>[] key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ((key[<span class="number">0</span>] &amp; <span class="number">0xff</span>)&lt;&lt; <span class="number">2</span>) | ((key[<span class="number">1</span>] &amp; <span class="number">0xff</span>)&gt;&gt; <span class="number">6</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>明确了高位分区的前提再来看整体的架构就变得明朗了</p>
<p>** 全局视角 **</p>
<p><img src="https://image.cnkirito.cn/KiritoDB.png" alt="全局视角"></p>
<p>** 分区视角 **</p>
<p><img src="https://image.cnkirito.cn/image-20181210204156199.png" alt="分区视角"></p>
<p>** 内存视角 **</p>
<p>内存中仅仅维护有序的 <code>key[1024][625000]</code> 数组和 <code>offset[1024][625000]</code> 数组。</p>
<p>上述两张图对整体的架构进行了一个很好的诠释，利用数据分布均匀的特性，可以将全局数据 hash 成 1024 个分区，在每个分区中存放两类文件：索引文件和数据文件。在随机写入阶段，根据 key 获得该数据对应分区位置，并按照时序，顺序追加到文件末尾，将全局随机写转换为局部顺序写。利用索引和数据一一对应的特性，我们也不需要将 data 的逻辑偏移量落盘，在 recover 阶段可以按照恢复 key 的次序，反推出 value 的逻辑偏移量。</p>
<p>在 range 阶段，由于我们事先按照 key 的高 10 为做了分区，所以我们可以认定一个事实，patition(N) 中的任何一个数据一定大于 partition(N-1) 中的任何一个数据，于是我们可以采用大块读，将一个 partition 整体读进内存，供 64 个 visit 线程消费。到这儿便奠定了整体的基调：读盘线程负责按分区读盘进入内存，64 个 visit 线程负责消费内存，按照 key 的次序随机访问内存，进行 Visitor 的回调。</p>
<h3 id="5-随机写流程"><a href="#5-随机写流程" class="headerlink" title="5 随机写流程"></a>5 随机写流程</h3><p>介绍完了整体架构，我们分阶段来看一下各个阶段的一些细节优化点，有一些优化在各个环节都会出现，未避免重复，第二次出现的同一优化点我就不赘述了，仅一句带过。</p>
<h4 id="使用-pageCache-实现写入缓冲区"><a href="#使用-pageCache-实现写入缓冲区" class="headerlink" title="使用 pageCache 实现写入缓冲区"></a>使用 pageCache 实现写入缓冲区</h4><p>主要看数据落盘，后讨论索引落盘。磁盘 IO 类型的比赛，第一步便是测量磁盘的 IOPS 以及多少个线程一次读写多大的缓存能够打满 IO，在固定 64 线程写入的前提下，16kb，64kb 均可以达到最理想 IOPS，所以理所当然的想到，可以为每一个分区分配一个写入缓存，凑齐 4 个 value 落盘。但是此次比赛，要做到 kill -9 不丢失数据，不能简单地在内存中分配一个 <code>ByteBuffer.allocate(4096 * 4);</code>， 而是可以考虑使用 mmap 内存映射出一片写入缓冲，凑齐 4 个刷盘，这样在 kill -9 之后，PageCache 不会丢失。实测 16kb 落盘比 4kb 落盘要快 6s 左右。</p>
<p>索引文件的落盘则没有太大的争议，由于 key 的数据量为固定的 8B，所以 mmap 可以发挥出它写小数据的优势，将 pageCache 利用起来，实测 mmap 相比 filechannel 写索引要快 3s 左右，相信如果把 polardb 这块盘换做其他普通的 ssd，这个数值还要增加。</p>
<h4 id="写入时不维护内存索引，不写入数据偏移"><a href="#写入时不维护内存索引，不写入数据偏移" class="headerlink" title="写入时不维护内存索引，不写入数据偏移"></a>写入时不维护内存索引，不写入数据偏移</h4><p>一开始审题不清，在随机写之后误以为会立刻随机读，实际上每个阶段都是独立的，所以不需要在写入时维护内存索引；其次，之前的架构图中也已经提及，不需要写入连带 key+offset 一起写入文件，recover 阶段可以按照恢复索引的顺序，反推出 data 的逻辑偏移，因为我们的 key 和 data 在同一个分区内的位置是一一对应的。</p>
<h3 id="6-恢复流程"><a href="#6-恢复流程" class="headerlink" title="6 恢复流程"></a>6 恢复流程</h3><p>recover 阶段的逻辑实际上包含在程序的 open 接口之中，我们需要再数据库引擎启动时，将索引从数据文件恢复到内存之中，在这之中也存在一些细节优化点。</p>
<p>由于 1024 个分区的存在，我们可以使用 64 个线程 (经验值) 并发地恢复索引，使用快速排序对 <code>key[1024][625000]</code> 数组和 <code>offset[1024][625000]</code> 进行 sort，之后再 compact，对 key 进行去重。需要注意的一点是，不要使用结构体，将 key 和 offset 封装在一起，这会使得排序和之后的二分效率非常低，这之中涉及到 CPU 缓存行的知识点，不了解的读者可以翻阅我之前的博客: <a href="https://www.cnkirito.moe/cache-line/">《CPU Cache 与缓存行》</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// wrong</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KeyOffset</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> key;</span><br><span class="line">    <span class="keyword">int</span> offset;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>整个 recover 阶段耗时为 1s，跟 cpp 选手交流后发现恢复流程比之慢了 600ms，这中间让我觉得比较诡异，加载索引和排序不应该这么慢才对，最终也没有优化成功。</p>
<h3 id="7-随机读流程"><a href="#7-随机读流程" class="headerlink" title="7 随机读流程"></a>7 随机读流程</h3><p>随机读流程没有太大的优化点，优化空间实在有限，实现思路便是先根据 key 定位到分区，之后在有序的 key 数据中二分查找到 key/offset，拿到 data 的逻辑偏移和分区编号，便可以愉快的随机读了，随机读阶段没有太大的优化点，但仍然比 cpp 选手慢了 2-3s，可能是语言无法越过的差距。</p>
<h3 id="8-顺序读流程"><a href="#8-顺序读流程" class="headerlink" title="8 顺序读流程"></a>8 顺序读流程</h3><p>Range 环节是整个比赛的大头，也是拉开差距的分水岭。前面我们已经大概提到了 Range 的整体思路是一个生产者消费者模型，n 个生成者负责从磁盘读数据进入内存（n 作为变量，通过 benchmark 来确定多少合适，最终实测 n 为 4 时效果最佳），64 个消费者负责调用 visit 回调，来验证数据，visit 过程就是随机读内存的过程。在 Range 阶段，剩余的内存还有大概 1G 左右，所以我分配了 4 个堆外缓冲，一个 256M，从而可以缓存 4 个分区的数据，并且，我为每一个分区分配了一个读盘线程，负责 load 数据进入缓存，供 64 个消费者消费。</p>
<p>具体的顺序读架构可以参见下图：</p>
<p><img src="https://image.cnkirito.cn/image-20181210215200345.png" alt="range"></p>
<p>大体来看，便是 4 个 fetch 线程负责读盘，fetch thread n 负责 <code>partitionNo % 4 == n</code> 编号的分区，完成后通知 visit 消费。这中间充斥着比较多的互斥等待逻辑，并未在图中体现出来，大体如下：</p>
<ol>
<li>fetch thread 1~4 加载磁盘数据进入缓存是并发的</li>
<li>visit group 1~64 访问同一个 buffer 是并发的</li>
<li>visit group 1~64 访问不同 partition 对应的 buffer 是按照次序来进行的 (打到全局有序)</li>
<li>加载 partitonN 会阻塞 visit bufferN，visit bufferN 会阻塞加载 partitionN+4(相当于复用 4 块缓存)</li>
</ol>
<p>大块的加载读进缓存，最大程度复用，是 ReadSeq 部分的关键。顺序读两轮的成绩在 196~198s 左右，相比 C++ 又慢了 4s 左右。</p>
<h3 id="9-魔鬼在细节中"><a href="#9-魔鬼在细节中" class="headerlink" title="9 魔鬼在细节中"></a>9 魔鬼在细节中</h3><p>这儿是个分水岭，介绍完了整体架构和四个阶段的细节实现，下面就是介绍下具体的优化点了。</p>
<h3 id="10-Java-实现-Direct-IO"><a href="#10-Java-实现-Direct-IO" class="headerlink" title="10 Java 实现 Direct IO"></a>10 Java 实现 Direct IO</h3><p>由于这次比赛将 drop cache 的时间算进了测评程序之中，所以在不必要的地方应当尽量避免 pageCache，也就是说除了写索引之外，其他阶段不应该出现 pageCache。这对于 Java 选手来说可能是不小的障碍，因为 Java 原生没有提供 Direct IO，需要自己封装一套 JNA 接口，封装这套接口借鉴了开源框架 jaydio 的思路，感谢 @尘央的协助，大家可以在文末的代码中看到实现细节。这一点可以说是拦住了一大票 Java 选手。</p>
<p>Direct IO 需要注意的两个细节：</p>
<ol>
<li>分配的内存需要对齐，对应 jna 方法：posix_memalign</li>
<li>写入的数据需要对齐通常是 pageSize 的整数倍，实际使用了 pread 的 O_DIRECT</li>
</ol>
<h3 id="11-直接内存优于堆内内存"><a href="#11-直接内存优于堆内内存" class="headerlink" title="11 直接内存优于堆内内存"></a>11 直接内存优于堆内内存</h3><p>这一点在《文件 IO 操作的一些最佳实践》中有所提及，堆外内存的两大好处是减少了一份内存拷贝，并且对 gc 友好，在 Direct IO 的实现中，应该配备一套堆外内存的接口，才能发挥出最大的功效。尤其在 Range 阶段，一个缓存区的大小便对应一个 partition 数据分区的大小：256M，大块的内存，更加适合用 DirectByteBuffer 装载。</p>
<h3 id="12-JVM-调优"><a href="#12-JVM-调优" class="headerlink" title="12 JVM 调优"></a>12 JVM 调优</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-server -Xms2560m -Xmx2560m -XX:MaxDirectMemorySize=1024m -XX:NewRatio=4 -XX:+UseConcMarkSweepGC -XX:+UseParNewGC -XX:-UseBiasedLocking</span><br></pre></td></tr></table></figure>

<p>众所周知 newRatio 控制的是 young 区和 old 区大小的比例，官方推荐参数为  <code>-XX:NewRatio=1</code>，很多不注意的 Java 选手可能没有意识去修改它，会在无形中被 gc 拖累。经过和 @阿杜的讨论，最终得出的结论：</p>
<ol>
<li>young 区过大，对象在年轻代待得太久，多次拷贝</li>
<li>old 区过小，会频繁触发 old 区的 cms gc</li>
</ol>
<p>在比赛中这显得尤为重要，<code>-XX:NewRatio=4</code> 放大老年代可以有效的减少 cms gc 的次数，将 126 次 cms gc，下降到最终的 5 次。</p>
<h3 id="13-池化对象"><a href="#13-池化对象" class="headerlink" title="13 池化对象"></a>13 池化对象</h3><p>无论是 apache 的 ObjectPool 还是 Netty 中的 Recycler，还是 RingBuffer 中预先分配的对象，都在传达一种思想，对于那些反复需要 new 出来的东西，都可以池化，分配内存再回收，这也是一笔不小的开销。在此次比赛的场景下，没必要大费周章地动用对象池，直接一个 ThreadLocal 即可搞定，事实上我对 key/value 的写入和读取都进行了 ThreadLocal 的缓存，做到了永远不再循环中分配对象。</p>
<h3 id="14-减少线程切换"><a href="#14-减少线程切换" class="headerlink" title="14 减少线程切换"></a>14 减少线程切换</h3><p>无论是网络 IO 还是磁盘 IO，io worker 线程的时间片都显得尤为的可贵，在我的架构中，range 阶段主要分为了两类线程：64 个 visit 线程并发随机读内存，4 个 io 线程并发读磁盘。木桶效应，我们很容易定位到瓶颈在于 4 个 io 线程，在 wait/notify 的模型中，为了尽可能的减少 io 线程的时间片流失，可以考虑使用 while(true) 进行轮询，而 visit 线程则可以 sleep(1us) 避免 cpu 空转带来的整体性能下降，由于评测机拥有 64 core，所以这样的分配算是较为合理的，为此我实现了一个简单粗暴的信号量。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoopQuerySemaphore</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> permit;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LoopQuerySemaphore</span><span class="params">(<span class="keyword">boolean</span> permit)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.permit = permit;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// for 64 visit thread</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (!permit) &#123;</span><br><span class="line">            Thread.sleep(<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        permit = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// for 4 fetch thread</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acquireNoSleep</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (!permit) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        permit = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        permit = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>正确的在 IO 中 acquireNoSleep，在 Visit 中 acquire，可以让成绩相比使用普通的阻塞 Semaphore 提升 6s 左右。</p>
<h3 id="15-绑核"><a href="#15-绑核" class="headerlink" title="15 绑核"></a>15 绑核</h3><p>线上机器的抖动在所难免，避免 IO 线程的切换也并不仅仅能够用依靠 while(true) 的轮询，一个 CPU 级别的优化便是腾出 4 个核心专门给 IO 线程使用，完全地避免 IO 线程的时间片争用。在 Java 中这也不难实现，依赖万能的 github，我们可以轻松地实现 Affinity。github 传送门：<a target="_blank" rel="noopener" href="https://github.com/OpenHFT/Java-Thread-Affinity">https://github.com/OpenHFT/Java-Thread-Affinity</a></p>
<p>使用方式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="keyword">final</span> AffinityLock al2 = AffinityLock.acquireLock()) &#123;</span><br><span class="line">    <span class="comment">// do fetch ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方式可以让你的代码快 1~2 s，并且保持测评的稳定性。</p>
<h3 id="0-聊聊-FileChannel，MMAP，Direct-IO，聊聊比赛"><a href="#0-聊聊-FileChannel，MMAP，Direct-IO，聊聊比赛" class="headerlink" title="0 聊聊 FileChannel，MMAP，Direct IO，聊聊比赛"></a>0 聊聊 FileChannel，MMAP，Direct IO，聊聊比赛</h3><p>我在最终版本的代码中，几乎完全抛弃了 FileChannel，事实上，在不 Drop Cache 的场景下，它已经可以发挥出它利用 PageCache 的一些优势，并且优秀的 Java 存储引擎都主要使用了 FileChannel 来进行读写，在少量的场景下，使用了 MMAP 作为辅助，毕竟，MMAP 在写小数据量文件时存在其价值。</p>
<p>另外需要注意的一点，在跟 @96 年的亚普长谈的一个夜晚，发现 FileChannel 中出人意料的一个实现，在分配对内内存时，它仍然会拷贝一份堆外内存，这对于实际使用 FileChannel 的场景需要额外注意，这部分意料之外分配的内存很容易导致线上的问题（实际上已经遇到了，和 glibc 的 malloc 相关，当 buffer 大于 128k 时，会使用 mmap 分配一块内存作为缓存）</p>
<p>说回 FileChannel，MMAP，最容易想到的是 RocketMQ 之中对两者灵活的运用，不知道在其他 Java 实现的存储引擎之中，是不是可以考虑使用 Direct IO 来提升存储引擎的性能呢？我们可以设想一下，利用有限并且少量的 PageCache 来保证一致性，在主流程中使用 Direct IO 配合顺序读写是不是一种可以配套使用的方案，不仅仅 PolarDB，算作是参加本次比赛给予我的一个启发。</p>
<p>虽然无缘决赛，但使用 Java 取得这样的成绩还算不是特别难过，在 6400w 数据随机写，随机读，顺序读的场景下，Java 可以做到仅仅相差 C++ 不到 10s 的 overhead，我倒是觉得完全是可以接受的，哈哈。还有一些小的优化点就不在此赘述了，欢迎留言与我交流优化点和比赛感悟。</p>
<p>** 欢迎关注我的微信公众号：「Kirito 的技术分享」，关于文章的任何疑问都会得到回复，带来更多 Java 相关的技术分享。**</p>
<p><img src="https://image.cnkirito.cn/qrcode_for_gh_c06057be7960_258%20%281%29.jpg" alt="关注微信公众号"></p>
</div><div class="article-licensing box"><div class="licensing-title"><p>PolarDB 数据库性能大赛 Java 选手分享</p><p><a href="https://www.cnkirito.moe/polardb-race/">https://www.cnkirito.moe/polardb-race/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>徐靖峰</p></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2018-12-10</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2025-05-26</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icon" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a><a class="icon" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a><a class="icon" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><hr style="height:1px;margin:1rem 0"><div class="level is-mobile is-flex"><div class="article-tags is-size-7 is-uppercase"><i class="fas fa-tags has-text-grey"></i> <a class="link-muted" rel="tag" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库 </a></div></div><!--!--></article></div><div class="card"><div class="card-content"><h3 class="menu-label has-text-centered">喜欢这篇文章？打赏一下作者吧</h3><div class="buttons is-centered"><a class="button donate" data-type="alipay"><span class="icon is-small"><i class="fab fa-alipay"></i></span><span>支付宝</span><span class="qrcode"><img src="/img/alipay.png" alt="支付宝"></span></a><a class="button donate" data-type="wechat"><span class="icon is-small"><i class="fab fa-weixin"></i></span><span>微信</span><span class="qrcode"><img src="/img/wechatpay.png" alt="微信"></span></a></div></div></div><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/dubbo-url/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">Dubbo 中的 URL 统一模型</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/file-io-best-practise/"><span class="level-item">文件 IO 操作的一些最佳实践</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><!--!--></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/avatar.png" alt="徐靖峰"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">徐靖峰</p><p class="is-size-6 is-block">阿里巴巴中间件研发</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>中国·杭州</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">180</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">14</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">77</p></a></div></div></nav><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/wechat_public.jpg" alt="Kirito的技术分享"></figure><div class="level"><a class="level-item button is-primary is-rounded" target="_blank" rel="noopener">↑关注微信公众号↑</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/lexburner"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="WeChat" href="/img/wechat_public.jpg"><i class="fab fa-weixin"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="RSS" href="/atom.xml"><i class="fas fa-rss"></i></a></div></div></div><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="level is-mobile" href="#1-前言"><span class="level-left"><span class="level-item">1</span><span class="level-item">1 前言</span></span></a></li><li><a class="level is-mobile" href="#2-赛题概览"><span class="level-left"><span class="level-item">2</span><span class="level-item">2 赛题概览</span></span></a></li><li><a class="level is-mobile" href="#3-赛题剖析"><span class="level-left"><span class="level-item">3</span><span class="level-item">3 赛题剖析</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#3-1-key-8B-value-4kb"><span class="level-left"><span class="level-item">3.1</span><span class="level-item">3.1 key 8B, value 4kb</span></span></a></li><li><a class="level is-mobile" href="#3-2-kill-9-数据不丢失"><span class="level-left"><span class="level-item">3.2</span><span class="level-item">3.2 kill -9 数据不丢失</span></span></a></li><li><a class="level is-mobile" href="#3-3-分阶段测评"><span class="level-left"><span class="level-item">3.3</span><span class="level-item">3.3 分阶段测评</span></span></a></li><li><a class="level is-mobile" href="#3-4-清空-PageCache-的耗时"><span class="level-left"><span class="level-item">3.4</span><span class="level-item">3.4 清空 PageCache 的耗时</span></span></a></li><li><a class="level is-mobile" href="#3-5-key-的分布"><span class="level-left"><span class="level-item">3.5</span><span class="level-item">3.5 key 的分布</span></span></a></li><li><a class="level is-mobile" href="#3-6-Range-的缓存设计"><span class="level-left"><span class="level-item">3.6</span><span class="level-item">3.6 Range 的缓存设计</span></span></a></li></ul></li><li><a class="level is-mobile" href="#4-架构详解"><span class="level-left"><span class="level-item">4</span><span class="level-item">4 架构详解</span></span></a></li><li><a class="level is-mobile" href="#5-随机写流程"><span class="level-left"><span class="level-item">5</span><span class="level-item">5 随机写流程</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#使用-pageCache-实现写入缓冲区"><span class="level-left"><span class="level-item">5.1</span><span class="level-item">使用 pageCache 实现写入缓冲区</span></span></a></li><li><a class="level is-mobile" href="#写入时不维护内存索引，不写入数据偏移"><span class="level-left"><span class="level-item">5.2</span><span class="level-item">写入时不维护内存索引，不写入数据偏移</span></span></a></li></ul></li><li><a class="level is-mobile" href="#6-恢复流程"><span class="level-left"><span class="level-item">6</span><span class="level-item">6 恢复流程</span></span></a></li><li><a class="level is-mobile" href="#7-随机读流程"><span class="level-left"><span class="level-item">7</span><span class="level-item">7 随机读流程</span></span></a></li><li><a class="level is-mobile" href="#8-顺序读流程"><span class="level-left"><span class="level-item">8</span><span class="level-item">8 顺序读流程</span></span></a></li><li><a class="level is-mobile" href="#9-魔鬼在细节中"><span class="level-left"><span class="level-item">9</span><span class="level-item">9 魔鬼在细节中</span></span></a></li><li><a class="level is-mobile" href="#10-Java-实现-Direct-IO"><span class="level-left"><span class="level-item">10</span><span class="level-item">10 Java 实现 Direct IO</span></span></a></li><li><a class="level is-mobile" href="#11-直接内存优于堆内内存"><span class="level-left"><span class="level-item">11</span><span class="level-item">11 直接内存优于堆内内存</span></span></a></li><li><a class="level is-mobile" href="#12-JVM-调优"><span class="level-left"><span class="level-item">12</span><span class="level-item">12 JVM 调优</span></span></a></li><li><a class="level is-mobile" href="#13-池化对象"><span class="level-left"><span class="level-item">13</span><span class="level-item">13 池化对象</span></span></a></li><li><a class="level is-mobile" href="#14-减少线程切换"><span class="level-left"><span class="level-item">14</span><span class="level-item">14 减少线程切换</span></span></a></li><li><a class="level is-mobile" href="#15-绑核"><span class="level-left"><span class="level-item">15</span><span class="level-item">15 绑核</span></span></a></li><li><a class="level is-mobile" href="#0-聊聊-FileChannel，MMAP，Direct-IO，聊聊比赛"><span class="level-left"><span class="level-item">16</span><span class="level-item">0 聊聊 FileChannel，MMAP，Direct IO，聊聊比赛</span></span></a></li></ul></div></div><script src="/js/toc.js" defer></script></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/avatar.png" alt="徐靖峰|个人博客" height="28"></a><p class="is-size-7"><span>&copy; 2026 徐靖峰</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><div id="outdated"><h6>Your browser is out-of-date!</h6><p>Update your browser to view this website correctly.&amp;npsb;<a id="btnUpdateBrowser" target="_blank" rel="noopener" href="http://outdatedbrowser.com/">Update my browser now </a></p><p class="last"><a href="#" id="btnCloseUpdateBrowser" title="Close">×</a></p></div><script src="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.js" defer></script><script>window.addEventListener("load", function () {
            outdatedBrowser({
                bgColor: '#f25648',
                color: '#ffffff',
                lowerThan: 'object-fit' // display on IE11 or below
            });
        });</script><!--!--><!--!--><!--!--><script src="/js/scroll-animations.js" defer></script><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>