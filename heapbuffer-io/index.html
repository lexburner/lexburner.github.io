<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>使用堆内内存HeapByteBuffer的注意事项 - 徐靖峰|个人博客</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="Kirito的技术分享"><meta name="msapplication-TileImage" content="/img/avatar.png"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Kirito的技术分享"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="前言国庆假期一眨眼就过去了，本来在家躺平的很舒服，没怎么肝云原生编程挑战赛，传送门：https:&amp;#x2F;&amp;#x2F;tianchi.aliyun.com&amp;#x2F;s&amp;#x2F;8bf1fe4ae2aea736e692c31c6952042d ，偏偏对手们假期开始卷起来了，眼看就要被人反超了，吓得我赶紧继续优化了。比赛大概还有一个月才结束，Kirito 的详细方案也会在比赛结束后分享，这期间我会分享一些比赛中的一些通用优化或者细节知"><meta property="og:type" content="blog"><meta property="og:title" content="使用堆内内存HeapByteBuffer的注意事项"><meta property="og:url" content="https://www.cnkirito.moe/heapbuffer-io/"><meta property="og:site_name" content="徐靖峰|个人博客"><meta property="og:description" content="前言国庆假期一眨眼就过去了，本来在家躺平的很舒服，没怎么肝云原生编程挑战赛，传送门：https:&amp;#x2F;&amp;#x2F;tianchi.aliyun.com&amp;#x2F;s&amp;#x2F;8bf1fe4ae2aea736e692c31c6952042d ，偏偏对手们假期开始卷起来了，眼看就要被人反超了，吓得我赶紧继续优化了。比赛大概还有一个月才结束，Kirito 的详细方案也会在比赛结束后分享，这期间我会分享一些比赛中的一些通用优化或者细节知"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://www.cnkirito.moe/img/og_image.png"><meta property="article:published_time" content="2021-10-07T23:16:50.000Z"><meta property="article:modified_time" content="2025-07-01T03:18:09.731Z"><meta property="article:author" content="徐靖峰"><meta property="article:tag" content="文件IO"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://www.cnkirito.moe/heapbuffer-io/"},"headline":"使用堆内内存HeapByteBuffer的注意事项","image":["https://www.cnkirito.moe/img/og_image.png"],"datePublished":"2021-10-07T23:16:50.000Z","dateModified":"2025-07-01T03:18:09.731Z","author":{"@type":"Person","name":"徐靖峰"},"description":"前言国庆假期一眨眼就过去了，本来在家躺平的很舒服，没怎么肝云原生编程挑战赛，传送门：https:&#x2F;&#x2F;tianchi.aliyun.com&#x2F;s&#x2F;8bf1fe4ae2aea736e692c31c6952042d ，偏偏对手们假期开始卷起来了，眼看就要被人反超了，吓得我赶紧继续优化了。比赛大概还有一个月才结束，Kirito 的详细方案也会在比赛结束后分享，这期间我会分享一些比赛中的一些通用优化或者细节知"}</script><link rel="canonical" href="https://www.cnkirito.moe/heapbuffer-io/"><link rel="icon" href="/img/avatar.png"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.12.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><script src="https://www.googletagmanager.com/gtag/js?id=UA-118574570-1" async></script><script>window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
    
        gtag('config', 'UA-118574570-1');</script><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.css"><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><!--!--><!--!--><meta name="generator" content="Hexo 5.4.0"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/avatar.png" alt="徐靖峰|个人博客" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/.">主页</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/archives">归档</a><a class="navbar-item" href="/about">关于</a><a class="navbar-item" target="_blank" rel="noopener" href="https://github.com/YunaiV/onemall">开源项目</a></div><div class="navbar-end"><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-9-widescreen"><div class="card"><article class="card-content article" id="article-content" role="article"><h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal"><i class="fas fa-angle-double-right"></i>使用堆内内存HeapByteBuffer的注意事项</h1><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><i class="far fa-calendar-alt"> </i><time dateTime="${date_xml(page.date)}" title="${date_xml(page.date)}">2021-10-07</time></span><span class="level-item is-hidden-mobile"><i class="far fa-calendar-check"> </i><time dateTime="${date_xml(page.updated)}" title="${date_xml(page.updated)}">2025-07-01</time></span><span class="level-item"><a class="link-muted" href="/categories/%E6%96%87%E4%BB%B6IO/">文件IO</a></span><span class="level-item">14 分钟读完 (大约2083个字)</span></div></div><div class="content"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>国庆假期一眨眼就过去了，本来在家躺平的很舒服，没怎么肝云原生编程挑战赛，传送门：<a target="_blank" rel="noopener" href="https://tianchi.aliyun.com/s/8bf1fe4ae2aea736e692c31c6952042d">https://tianchi.aliyun.com/s/8bf1fe4ae2aea736e692c31c6952042d</a> ，偏偏对手们假期开始卷起来了，眼看就要被人反超了，吓得我赶紧继续优化了。比赛大概还有一个月才结束，Kirito 的详细方案也会在比赛结束后分享，这期间我会分享一些比赛中的一些通用优化或者细节知识点，例如本文就是这么一个例子。</p>
<p>趁着假期最后一天，分享一个很多人容易踩得一个坑：HeapByteBuffer 的使用问题。我们都知道 NIO 分装了 ByteBuffer 接口，使得 filechannel 的文件 IO API 变得非常的简单。ByteBuffer 主要有两个实现类</p>
<ul>
<li>HeapByteBuffer 堆内内存</li>
<li>DirectByteBuffer 堆外内存</li>
</ul>
<p>按我的个人经验，大多数情况，无论是读操作还是写操作，我都倾向于使用 DirectByteBuffer，主要是因为 HeapByteBuffer 在和 FileChannel 交互时，可能会有一些出乎大家意料的内部操作，也就是这篇文章的标题中提到的注意事项，这里先卖个关子。</p>
<p>先来看看这次比赛为什么要用到 HeapByteBuffer 呢？</p>
<p>原因一：赛题需要设计分级存储，并且提供了 6G 堆内内存 + 2G 堆外内存，一个最直接的思路便是使用内存来存储热点数据，而内存存储数据最方便的数据结构便是 ByteBuffer 了。</p>
<p>原因二：由于堆内 6G 远大于堆外 2G，且 JVM 参数不能调整，所以要想利用好堆内富余的内存去做缓存，非 HeapByteBuffer 莫属了。</p>
<p>可能有一些读者并没有关注赛题，我这里简化一下前言，可以直接理解为：有一块 2G 的 HeapByteBuffer 用于文件 IO，我们该如何利用。</p>
<span id="more"></span>

<h2 id="HeapByteBuffer-的复制问题"><a href="#HeapByteBuffer-的复制问题" class="headerlink" title="HeapByteBuffer 的复制问题"></a>HeapByteBuffer 的复制问题</h2><p>废话不多说，直接来看 HeapByteBuffer 的坑在哪儿。</p>
<p>使用代码描述 HeapByteBuffer 的文件 IO 操作，大概率会写出如下的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readInOneThread</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> bufferSize = <span class="number">50</span> * <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line">    File file = <span class="keyword">new</span> File(<span class="string">&quot;/essd&quot;</span>);</span><br><span class="line">    FileChannel fileChannel = <span class="keyword">new</span> RandomAccessFile(file, <span class="string">&quot;rw&quot;</span>).getChannel();</span><br><span class="line">    ByteBuffer byteBuffer = ByteBuffer.allocate(bufferSize);</span><br><span class="line">    fileChannel.read(byteBuffer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述的代码，将文件中的数据缓存到了内存中，无论是赛题还是生产场景，这个行为通常都是多线程的，例如在云原生编程挑战赛的评测下，有 40 个线程进行读写，如果按照线程维度进行缓存，每个线程分到 50M 用于内存缓存自然是没有问题。</p>
<p>而如果你直接使用上述代码，在评测中可能会直接得到内存溢出相关的异常。其实我在之前堆外内存泄漏的文章中也提到过这个问题，不过角度有所不同。原因很简单，直接来看源码。</p>
<p>FileChannel 使用的是 IOUtil 进行读写操作</p>
<figure class="highlight java"><figcaption><span>sun.nio.ch.IOUtil#read</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(FileDescriptor var0, ByteBuffer var1, <span class="keyword">long</span> var2, NativeDispatcher var4)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (var1.isReadOnly()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Read-only buffer&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (var1 <span class="keyword">instanceof</span> DirectBuffer) &#123;</span><br><span class="line">        <span class="keyword">return</span> readIntoNativeBuffer(var0, var1, var2, var4);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ByteBuffer var5 = Util.getTemporaryDirectBuffer(var1.remaining());</span><br><span class="line">        <span class="keyword">int</span> var7;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> var6 = readIntoNativeBuffer(var0, var5, var2, var4);</span><br><span class="line">            var5.flip();</span><br><span class="line">            <span class="keyword">if</span> (var6 &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                var1.put(var5);</span><br><span class="line">            &#125;</span><br><span class="line">            var7 = var6;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            Util.offerFirstTemporaryDirectBuffer(var5);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> var7;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以发现当使用 HeapByteBuffer 时，会走到下面这个分支</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Util.getTemporaryDirectBuffer(var1.remaining());</span><br></pre></td></tr></table></figure>

<p>这个 Util 封装了更为底层的一些 IO 逻辑</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> sun.nio.ch;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Util</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;Util.BufferCache&gt; bufferCache;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ByteBuffer <span class="title">getTemporaryDirectBuffer</span><span class="params">(<span class="keyword">int</span> var0)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isBufferTooLarge(var0)) &#123;</span><br><span class="line">            <span class="keyword">return</span> ByteBuffer.allocateDirect(var0);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// FOUCS ON THIS LINE</span></span><br><span class="line">            Util.BufferCache var1 = (Util.BufferCache)bufferCache.get();</span><br><span class="line">            ByteBuffer var2 = var1.get(var0);</span><br><span class="line">            <span class="keyword">if</span> (var2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> var2;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!var1.isEmpty()) &#123;</span><br><span class="line">                    var2 = var1.removeFirst();</span><br><span class="line">                    free(var2);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> ByteBuffer.allocateDirect(var0);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>isBufferTooLarge 这个方法会根据传入 Buffer 的大小决定如何分配堆外内存，如果过大，直接分配大缓冲区；如果不是太大，会使用 bufferCache 这个 ThreadLocal 变量来进行缓存，从而复用（实际上这个数值非常大，几乎不会走进直接分配堆外内存这个分支）。这么看来似乎发现了两个不得了的结论：</p>
<ol>
<li>使用 HeapByteBuffer 读写都会经过 DirectByteBuffer，写入数据的流转方式其实是：HeapByteBuffer -&gt; DirectByteBuffer -&gt; PageCache -&gt; Disk，读取数据的流转方式正好相反。</li>
<li>使用 HeapByteBuffer 读写会申请一块跟线程绑定的 DirectByteBuffer。这意味着，线程越多，临时 DirectByteBuffer 就越会占用越多的空间。</li>
</ol>
<p>根据这两个结论，我们再回到赛题中，如果直接按照上述的方式进行读写，40 个线程每个都持有一个 50M 的堆内内存，同时又因为 IOUtil  的内部行为，额外分配了 40*50M 的堆外内存， 堆外内存在不经意间就被用光了！出现堆外内存溢出的异常也就不奇怪了。</p>
<h2 id="为什么-HeapByteBuffer-在-IO-时需要复制到-DirectByteBuffer"><a href="#为什么-HeapByteBuffer-在-IO-时需要复制到-DirectByteBuffer" class="headerlink" title="为什么 HeapByteBuffer 在 IO 时需要复制到 DirectByteBuffer"></a>为什么 HeapByteBuffer 在 IO 时需要复制到 DirectByteBuffer</h2><p>这个我之前也介绍过，详情可以参考我的一篇旧文：《一文探讨堆外内存的监控与回收》。总结如下：</p>
<ul>
<li>为了方便 GC 的实现，DirectByteBuffer 指向的 native memory 是不受 GC 管辖的</li>
<li>HeapByteBuffer 背后使用的是 byte 数组，其占用的内存不一定是连续的，不太方便 JNI 方法的调用</li>
<li>数组实现在不同 JVM 中可能会不同</li>
</ul>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>其实我们本质上是为了给每个线程维护一块 HeapByteBuffer，用于缓存数据，并没有必要以 ByteBuffer 的大小为维度来进行 IO。可以借鉴 IOUtil 中复制 DirectByteBuffer 的思路来优化这一过程。代码示例如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">directBufferCopy</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    File file = <span class="keyword">new</span> File(<span class="string">&quot;/essd&quot;</span>);</span><br><span class="line">    FileChannel fileChannel = <span class="keyword">new</span> RandomAccessFile(file, <span class="string">&quot;rw&quot;</span>).getChannel();</span><br><span class="line">    ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="number">50</span> * <span class="number">1024</span> * <span class="number">1024</span>);</span><br><span class="line">    ByteBuffer directByteBuffer = ByteBuffer.allocateDirect(<span class="number">4</span> * <span class="number">1024</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">12800</span>; i++) &#123;</span><br><span class="line">        directByteBuffer.clear();</span><br><span class="line">        fileChannel.read(directByteBuffer, i * <span class="number">4</span> * <span class="number">1024</span>);</span><br><span class="line">        directByteBuffer.flip();</span><br><span class="line">        byteBuffer.put(directByteBuffer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 Java 中，从磁盘到堆内内存，一定无法省略堆外内存的复制，但我们可以自己复制，从而使得这个过程更加直观地被我们自己操控，而不是被 FileChannel 的内部逻辑左右。</p>
<p>这里也需要注意</p>
<ul>
<li>单次 IO 使用的 DirectByteBuffer 不宜过大，仅仅作为一个运输载体，起到一个运输数据的作用。这样在多线程场景下，才不至于占用过多的堆外内存</li>
<li>单次 IO 使用的 DirectByteBuffer 不宜过小，否则会出现读写放大的问题，一般建议设置 4kb 的整数倍，具体以实际测试结果为准。</li>
</ul>
<h2 id="其他注意事项"><a href="#其他注意事项" class="headerlink" title="其他注意事项"></a>其他注意事项</h2><p>HeapByteBuffer 读写时的复制问题是本文的主角，但使用 HeapByteBuffer 作为缓存时，也需要注意一些其他问题。例如比赛场景中，你可能希望开辟一大块 HeapByteBuffer，6G 堆内内存，分配个 4G 用作缓存总可以吧？可不可以我说了不算，你感兴趣的话倒是可以测试一下是否可行，还需要考虑 GC 情况，需要综合考虑老年代和新生代的配比，如果你分配了过多堆内内存给 HeapByteBuffer 缓存，可能会直接导致 OutOfMemory 或者触发 GC。</p>
<p>同时，如果 HeapByteBuffer 占用了过多内存，留给操作系统的 PageCache 也会非常有限，这两者使用的可是同一块内存！如果你的程序利用到了 PageCache 的特性，可能会由于 PageCache 空间不够，导致 IO 速度变慢。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文介绍了在文件 IO 中使用 HeapByteBuffer 的注意事项，需要考虑到 FileChannel 内部的复制问题，意识到这一过程会有堆外内存的复制开销。在实际使用场景中，个人更加推荐直接使用 DirectByteBuffer 进行 IO 操作。如果出于某些原因，一定需要使用 HeapByteBuffer 存储作为缓存，可以参考文中分批使用 DirectByteBuffer 进行 IO 并复制的方案。</p>
</div><div class="article-licensing box"><div class="licensing-title"><p>使用堆内内存HeapByteBuffer的注意事项</p><p><a href="https://www.cnkirito.moe/heapbuffer-io/">https://www.cnkirito.moe/heapbuffer-io/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>徐靖峰</p></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2021-10-07</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2025-07-01</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icon" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a><a class="icon" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a><a class="icon" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><hr style="height:1px;margin:1rem 0"><div class="level is-mobile is-flex"><div class="article-tags is-size-7 is-uppercase"><i class="fas fa-tags has-text-grey"></i> <a class="link-muted" rel="tag" href="/tags/%E6%96%87%E4%BB%B6IO/">文件IO </a></div></div><!--!--></article></div><div class="card"><div class="card-content"><h3 class="menu-label has-text-centered">喜欢这篇文章？打赏一下作者吧</h3><div class="buttons is-centered"><a class="button donate" data-type="alipay"><span class="icon is-small"><i class="fab fa-alipay"></i></span><span>支付宝</span><span class="qrcode"><img src="/img/alipay.png" alt="支付宝"></span></a><a class="button donate" data-type="wechat"><span class="icon is-small"><i class="fab fa-weixin"></i></span><span>微信</span><span class="qrcode"><img src="/img/wechatpay.png" alt="微信"></span></a></div></div></div><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/unsafe/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">聊聊Unsafe的一些使用技巧</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/filechannel_force/"><span class="level-item">文件 IO 中如何保证掉电不丢失数据</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><!--!--><div><script src="https://readmore.openwrite.cn/js/readmore.js" type="text/javascript"></script>
            <script>
                const btw = new BTWPlugin();
                btw.init({
                    id: "article-content",
                    blogId: '10053-1610820399501-222',
                    name: 'Kirito的技术分享',
                    qrcode: 'http://image.cnkirito.cn/qrcode_for_gh_c06057be7960_258%20%281%29.jpg',
                    keyword: 'more'
                });
                var rm_btn = $('#read-more-btn');
                rm_btn.html('~阅读全文~人机检测~');
            </script>
            </div></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/avatar.png" alt="徐靖峰"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">徐靖峰</p><p class="is-size-6 is-block">阿里巴巴中间件研发</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>中国·杭州</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">177</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">22</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">77</p></a></div></div></nav><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/wechat_public.jpg" alt="Kirito的技术分享"></figure><div class="level"><a class="level-item button is-primary is-rounded" target="_blank" rel="noopener">↑关注微信公众号↑</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/lexburner"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="WeChat" href="/img/wechat_public.jpg"><i class="fab fa-weixin"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="RSS" href="/atom.xml"><i class="fas fa-rss"></i></a></div></div></div><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="level is-mobile" href="#前言"><span class="level-left"><span class="level-item">1</span><span class="level-item">前言</span></span></a></li><li><a class="level is-mobile" href="#HeapByteBuffer-的复制问题"><span class="level-left"><span class="level-item">2</span><span class="level-item">HeapByteBuffer 的复制问题</span></span></a></li><li><a class="level is-mobile" href="#为什么-HeapByteBuffer-在-IO-时需要复制到-DirectByteBuffer"><span class="level-left"><span class="level-item">3</span><span class="level-item">为什么 HeapByteBuffer 在 IO 时需要复制到 DirectByteBuffer</span></span></a></li><li><a class="level is-mobile" href="#解决方案"><span class="level-left"><span class="level-item">4</span><span class="level-item">解决方案</span></span></a></li><li><a class="level is-mobile" href="#其他注意事项"><span class="level-left"><span class="level-item">5</span><span class="level-item">其他注意事项</span></span></a></li><li><a class="level is-mobile" href="#总结"><span class="level-left"><span class="level-item">6</span><span class="level-item">总结</span></span></a></li></ul></div></div><script src="/js/toc.js" defer></script></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/avatar.png" alt="徐靖峰|个人博客" height="28"></a><p class="is-size-7"><span>&copy; 2025 徐靖峰</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><div id="outdated"><h6>Your browser is out-of-date!</h6><p>Update your browser to view this website correctly.&amp;npsb;<a id="btnUpdateBrowser" target="_blank" rel="noopener" href="http://outdatedbrowser.com/">Update my browser now </a></p><p class="last"><a href="#" id="btnCloseUpdateBrowser" title="Close">×</a></p></div><script src="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.js" defer></script><script>window.addEventListener("load", function () {
            outdatedBrowser({
                bgColor: '#f25648',
                color: '#ffffff',
                lowerThan: 'object-fit' // display on IE11 or below
            });
        });</script><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>